# 이미지 다루기 #

## 이미지 읽고 쓰기 ##
아직까지 이미지를 정식으로 다루지는 않았지만 이미 여러 번 이미지 파일을 다루었습니다. 이제 정식으로 이미지 파일을 다루는 법을 배워봅시다.
### 내 컴퓨터에서 이미지 읽기 ###
우선 이미지 파일을 추가합니다. 이미지 파일을 드래그해서 프로세싱 코드 편집창 위로 떨굽시다.

이렇게 이미지 파일을 추가한 이미지를 프로세싱에서 사용하는 데는 두 단계가 필요합니다.
#### 이미지 파일 변수 지정 ####
우선 이미지를 읽어들여야 합니다. 이미지를 불러와 이미지 파일을 지칭하는 변수에 저장을 합니다. 이미지 파일 자체를 변수에 저장하는 것이 아니라 이미지 파일을 참고(reference)하는 방법은 편리하고 여러 군데서 사용됩니다.

이미지 파일을 가리키는 변수는 PImage 타입을 띕니다. 더 정확하게 이야기하자면 PImage 클래스의 인스턴스라고 지칭하는 것이 맞지만 일단은 넘어가기로 합시다. 이것이 무슨 말인지 궁금하시면 조금만 기다려주세요. 객체지향 프로그래밍에 대해 배우게 되면 이 말이 어떤 뜻인지 알게 될 것입니다. 이미지 파일을 가리키는 변수는 일단 Pimage 타입을 가진다고 이해하고 넘어갑시다.

	PImage img;

loadImage() 함수는 이미지 파일의 위치를 입력값을 받아 변수에 저장합니다. 

	PImage img = loadImage("yourImage.jpg");

파일의 정확한 위치를 지정하면 내 컴퓨터에 있는 이미지 파일을 어떤 것이나 변수에 저장할 수 있습니다.

#### 화면에 이미지 띄우기 ####
이제 정말 화면에 이미지를 표시할 차례입니다. image() 함수를 이용해 이미지를 화면에 띄울 수 있습니다. 자세한 설명을 하기 전 일단 동작하는 예를 보고 설명을 이어갑시다.

복잡한 기능을 가지고 있는 프로그램을 한 번에 모두 작성하려고 하는 시도는 120%의 확류로 실패합니다. 언제나 작게 조금씩 기능을 추가하고 새로운 라인을 추가하면 자주 제대로 돌아가는지 확인하는 습관을 기르는 것도 좋겠습니다.

	//myHelloImage
	PImage img;
	void setup() {
		size(480, 360);
		img = loadImage("myImage.jpg");
	}

	void draw() {
		image(img, 0, 0, 240, 180);
		image(img, 240, 0, 240, 180);
		image(img, 0, 180, 480, 180);
	}
![](http://i.imgur.com/7NJWDBS.jpg)

[원본 링크](https://www.wallsandfloors.co.uk/range/jewel-tone-prismatic-tiles)

image() 파일의 입력값을 살펴봅시다.

	image(PImage img, float x, float y, float imageWidth, float imageHeight);

표시할 이미지를 정하고, 이미지의 위치를 정합니다. 그리고 이미지의 너비와 높이를 정합니다. 혹시 너비와 높이를 따로 정하지 않으면 화면의 크기인 width와 height를 기본값으로 사용합니다.
### 웹에서 이미지 읽기 ###
웹에서 이미지를 가져오는 것과 내 컴퓨터에서 이미지 파일을 가져오는 것은 차이가 거의 없습니다. 이미지 파일의 위치를 loadImage()에 입력하는 대신 이미지 파일의 URL주소를 입력해야 하는 차이가 있을 뿐입니다.

	//myHelloWebImage
	String URL = "http://cfile3.uf.tistory.com/image/222B06505657E2700AD5B9";
	
	PImage img;
	
	void setup() {
		size(740, 1108);
		img = loadImage(URL, "jpg");
	}
	
	void draw() {
		image(img, 0, 0);
	}
![](http://i.imgur.com/WjuBJOA.jpg)

이제 이미지 파일 주소만 알면 언제든지 파일을 화면에 띄울 수 있습니다.
## 이미지 변형하기 ##
주어진 이미지를 그대로 사용하는데는 한계가 있습니다. 우선 이미지에서 원하는 부분을 떼어내는 것부터 연습합시다. 다음 섹션에서 모자이크를 만들때 바로 써먹을 기술입니다. 
### 이미지 잘라내기 ###
이전에 설명하기를 프로세싱은 여러 데이터 타입을 가지고 있고 연산되는 방식이 데이터 타입에 따라 다르다고 했습니다. 이미지 타입을 지칭하는 PImage 타입(정확하게 말하면 클래스)도 이미지를 어떻게 연산하는지 미리 정해두었습니다. PImage 타입이 어떻게 연산 혹은 동작하는지를 정한 함수(정확하게는 메서드)를 이용하면
우리가 원하는 작업을 쉽게 할 수 있습니다.

이미지를 잘라내는 작업은 get() 메서드를 사용하면 쉽게 할 수 있습니다. 설명을 이어가기 전 우선 get() 메서드를 이용한 예를 먼저 보겠습니다.

	//myGetMethod
	PImage img;
	PImage cropped;
	
	void setup() {
		size(1000, 848);
		imageMode(CENTER);
		img = loadImage("http://nktrend.diskn.com/00_gf/gf_002.jpg");
	
		cropped = img.get(0, 0, width, height / 2);
		frameRate(1);
	}
	
	void draw() {
		background(255);
		translate(width / 2.0, height / 2.0);
		if (0 == frameCount % 2) {
			image(img, 0, 0);
		}
		else {
			image(cropped, 0, 0);
		}
	}
![](http://i.imgur.com/H7veFFx.jpg)
![](http://i.imgur.com/K4iUWBm.jpg)

get 메서드는 가지고 올 이미지의 시작과 끝, 너비와 높이를 입력값으로 받아서 이미지 파일을 잘라냅니다.

	get(int x, int y, int width, int height);

혹시 너비와 높이를 정하지 않으면 (x, y) 지점의 픽셀값 하나만 떼옵니다.

## 이미지 모자이크 만들기 ##
유명한 회화의 일부를 잘라 다시 배열해 봅시다. 생각보다 재미있는 패턴이 들어나는 것을 발견할 수 있습니다. 이미지 다루는 법을 연습하는 좋은 기회입니다.
### 이미지 자르기 ###
이미지를 화면에 띄우고 마우스를 따라 작은 사각형을 이미지 위에 띄우도록 합시다. 사각형 내부의 이미지가 원본에서 떼어낼 부분입니다.

#### 이미지 띄우기와 사각형 그리기 ####
하나씩 원하는 기능을 추가해 가는 것이 오히려 한꺼번에 모든 기능을 추가하려는 것보다 더 빨리 완성할 때가 많습니다. 일단 이미지를 띄우고 사각형을 그리는 것에 집중합시다.

	//myCropRect
	
	PImage img;
	PImage cropped;
	String URL = "http://c85c7a.medialib.glogster.com/media/b3/b32d597d70ee28fe942e2a8e7b485684456a4b0ffc7c955a4d6cb874ee60d894/mondrian1.jpg";
	
	int tileWidth = 128;
	int tileHeight = 96;
	
	void setup() {
		size(1024, 768);
		img = loadImage(URL);
	}
	
	void draw() {
		image(img, 0, 0);
		int posX = constrain(mouseX, 0, width - tileWidth);
		int posY = constrain(mouseY, 0, height - tileHeight);
		
		stroke(255);
		strokeWeight(2);
		noFill();
	
		rect(posX, posY, tileWidth, tileHeight);
	}

	

#### 이미지 잘라내기 ####
이미지를 잘라내는 것은 이전에 설명한 것처럼 get() 메서드를 이용합니다. 이전에 배웠던 내용을 다시 확인해 볼까요? 마우스를 클릭하는 동안 사각형 내부의 이미지가 전체 화면으로 확대되게 만들어 보겠습니다.

	//myCropImage
	
	PImage img;
	PImage cropped;
	String URL = "http://c85c7a.medialib.glogster.com/media/b3/b32d597d70ee28fe942e2a8e7b485684456a4b0ffc7c955a4d6cb874ee60d894/mondrian1.jpg";
	
	int tileWidth = 128;
	int tileHeight = 96;
	
	void setup() {
		size(1024, 768);
		img = loadImage(URL);
	}
	
	void draw() {
		image(img, 0, 0);
		int posX = constrain(mouseX, 0, width - tileWidth);
		int posY = constrain(mouseY, 0, height - tileHeight);
		
		stroke(255);
		strokeWeight(2);
		noFill();
	
		rect(posX, posY, tileWidth, tileHeight);

		if(mousePressed) {
			cropped = img.get(posX, posY, tileWidth, tileHeight);
			image(cropped, 0, 0, width, height);
		}
	}

![](http://i.imgur.com/IJP7vRh.jpg)
![](http://i.imgur.com/ZEsHh7V.jpg)
### 이미지 배치하기 ###
이제 잘라낸 이미지를 전체 화면에 표시하지 않고 화면에 반복해서 표시하겠습니다. 지금까지 했던 작업과 크게 다르지 않습니다. 몇 개의 변수를 추가해서 화면에 배치하는 작업을 쉽게 하겠습니다.

	//myCropImageDisplay	
	PImage img;
	PImage cropped;

	boolean mosaicMode = false;

	String URL = "http://c85c7a.medialib.glogster.com/media/b3/b32d597d70ee28fe942e2a8e7b485684456a4b0ffc7c955a4d6cb874ee60d894/mondrian1.jpg";
	
	int tileWidth = 128;
	int tileHeight = 96;
	int nX;
	int nY;
	int posX;
	int posY;
	
	void setup() {
		size(1024, 768);
		img = loadImage(URL);
		nX = width / tileWidth;
		nY = height / tileHeight;
	}
	
	void draw() {
		image(img, 0, 0);
		posX = constrain(mouseX, 0, width - tileWidth);
		posY = constrain(mouseY, 0, height - tileHeight);
		
		stroke(255);
		strokeWeight(2);
		noFill();
	
		rect(posX, posY, tileWidth, tileHeight);

		if(mosaicMode) {
			for(int y  = 0; y < nY; y++) {
				for(int x = 0; x < nX; x++) {
					image(cropped, x * tileWidth, y * tileHeight);
				}
			}
		}
	}
	
	void mousePressed() {
		cropped = img.get(posX, posY, tileWidth, tileHeight);
		mosaicMode = true;
	}

	void mouseMoved() {
		mosaicMode = false;
	}

![](http://i.imgur.com/AFmgqpD.jpg)
![](http://i.imgur.com/i9Bjf4S.jpg)
### 이미지 임의로 자르기 ###
하지만 너무 정확하게 같은 조각을 자르면 재미가 없습니다. 자를 때 약간씩 오차를 허용하면 어떨까요? random() 함수를 이용해 오차를 발생합시다. 

덧붙여 각각의 조각들을 담을 배열을 아래와 같이 정의해서 조각을 저장합시다.

	PImage[][] crops = new PImage[nY][nX];

실제 코드를 써보면 아래와 같습니다.

	//myCropImageDisplayRandom	
	PImage img;
	PImage[][] crops;

	boolean mosaicMode = false;

	String URL = "http://c85c7a.medialib.glogster.com/media/b3/b32d597d70ee28fe942e2a8e7b485684456a4b0ffc7c955a4d6cb874ee60d894/mondrian1.jpg";
	
	int tileWidth = 128;
	int tileHeight = 96;
	int nX;
	int nY;
	int posX;
	int posY;
	
	void setup() {
		size(1024, 768);
		img = loadImage(URL);
		nX = width / tileWidth;
		nY = height / tileHeight;
		crops = new PImage[nY][nX];
	}
	
	void draw() {
		image(img, 0, 0);
		posX = constrain(mouseX, 0, width - tileWidth);
		posY = constrain(mouseY, 0, height - tileHeight);
		
		stroke(255);
		strokeWeight(2);
		noFill();
	
		rect(posX, posY, tileWidth, tileHeight);

		if(mosaicMode) {
			for(int y  = 0; y < nY; y++) {
				for(int x = 0; x < nX; x++) {
					image(crops[y][x], x * tileWidth, y * tileHeight);
				}
			}
		}
	}
	
	void mousePressed() {
		for (int y = 0; y < nY; y++) {
			for (int x = 0; x < nX; x++) {
				int posRX = int(posX + 0.5 * tileWidth * random(-1, 1));
				int posRY = int(posY + 0.5 * tileHeight * random(-1, 1));
				crops[y][x] = img.get(posRX, posRY, tileWidth, tileHeight);
			}
		}
		mosaicMode = true;
	}

	void mouseMoved() {
		mosaicMode = false;
	}

![](http://i.imgur.com/imGmkTe.jpg)
![](http://i.imgur.com/oPkiiJ3.jpg)

다시 한 번 외쳐봅시다. 그럴 듯한 작품을 만드는 데 엄청난 지식이 필요한 것은 아닙니다. 약간만 배워도 조금만 알아도 이런 재미있는 일들을 할 수 있습니다. 여러분 두려워 마시고 함께 배워봅시다.
## 평균 얼굴 만들기 ##
가끔씩 한국인의 평균얼굴 혹은 나라별 평균얼굴과 같은 사진을 기사에서 볼 수 있습니다. 혹시 이거 어떻게 한 것인지 궁금하지 않으십니까?

생각보다 간단한 원리입니다. 이미지를 투명하게 만들어 계속 겹쳐서 그리면 평균 얼굴이 화면에 남게 됩니다. 한 번 해볼까요?

### 얼굴 파일 구하기 ###
먼저 적당한 얼굴 파일을 모아야 합니다. 다음 시간에 배울 테크닉을 우선 적용해 봅시다. 자세한 내용은 다음 장에서 공부하고 여기서는 웹페이지를 분석해 웹페이지에 나온 이미지 링크를 이용해 얼굴 파일을 컴퓨터에 저장하는 작업이라는 정도로 이해하는 것으로 충분합니다.

	//myGettingFaceImages
	import java.util.ArrayList;
	import org.jsoup.Jsoup;
	import org.jsoup.nodes.Document;
	import org.jsoup.nodes.Element;
	import org.jsoup.select.Elements;
	
	String BASE_URL = "http://www.faceresearch.org";
	String web_page_url = BASE_URL + "/demos/average";
	
	ArrayList<String> imageURLs= new ArrayList<String>();
	PImage img;
	
	void setup() {
		String html = join(loadStrings(web_page_url), "");
		Document doc = Jsoup.parse(html);
		Elements inputs = doc.select("input[type=checkbox]");

		for (Element input : inputs) {
			String imageURL = trim(BASE_URL + input.attr("value"));
			imageURLs.add(imageURL);
			println(imageURL);
			PImage image = loadImage(imageURL);
			//substring(starting_index, ending_index);
			image.save(imageURL.substring(46, 57));
		}
	}

[원본 파일 위치](http://www.faceresearch.org/demos/average)
### 겹치기 ###
얼굴 파일은 현재 프로세싱 스케치 내부의 data폴더에 저장되어 있습니다. tint() 함수를 이용해 투명도를 조정한 다음 화면에 얼굴을 겹쳐 띄워봅시다.

	//myGettingFaceImages
	import java.io.File;
	File folder;
	File[] files;
	
	String fileName;
	PImage img;

	void setup() {
		size(600, 800);
		folder = new File(dataPath(""));
		files = folder.listFiles();
		tint(255, 3);
		frameRate(5);
		background(255);
	}
	
	void draw() {
		fileName = files[frameCount % files.length].getName();
		img = loadImage(fileName);
		image(img, 0, 0, 600, 800);
		if (frameCount > files.length) {
			noLoop();
		}
		println(frameCount);
	}

![](http://i.imgur.com/yRxJNiY.jpg)

생각보다 쉽지 않나요? 그럴듯한 작업을 하기 위해서 알고 있어야 하는 지식은 사실 얼마되지 않습니다. 약간의 프로그래밍 지식만으로도 멋진 작업을 할 수 있습니다.
### celebrities ###
유명인의 사진으로도 같은 작업을 할 수 있습니다.

	//myCelebrities
	import java.io.File;
	String[] names = new String[]{"xavier","magneto","wolverine","rogue","storm","burn_gorman","charlie_day","idris_elba","rinko_kikuchi","mads_mikkelsohn","hugh_dancy","gillian_anderson","scarlett_johansson","sebastian_stan","chris_evans","anthony_mackie","hayley_atwell","lucy_liu","sendhil_ramamurthy","orlando_jones","benedict_cumberbatch","chris_pine","zachary_quinto","zoe_saldana","anton_yelchin","karl_urban","john_cho","simon_pegg"};
	
	String BASE_URL = "http://psychomorph.facelab.org/demo/celebs/";
	
	File[] files;
	File folder;
	
	void setup() {
		//getImages();
		folder = new File(dataPath(""));
		files = folder.listFiles();
		size(600, 400);
		background(255);
		frameRate(1);
	}
	  
	void draw() {
		PImage img = loadImage(files[frameCount % files.length].getName());
		tint(255, 20);
		image(img, 0, 0, 300, 400);
		noTint();
		image(img, 300, 0, 300, 400);
		if (frameCount > files.length) {
			noLoop();
		}
	}
	
	void keyPressed() {
		if (key == 's' || key == 'S') {
			saveFrame("myCelebrities####.jpg");
		}
	}
	
	void getImages() {
		for (int i = 0; i < names.length; i++) {
			PImage img = loadImage(BASE_URL + names[i], "jpg");
			img.save("data/" + names[i] + ".jpg");
		}
	}

![](http://i.imgur.com/P5ojgVl.jpg)
![](http://i.imgur.com/UsNdhAT.jpg)
![](http://i.imgur.com/eG6Ahzd.jpg)