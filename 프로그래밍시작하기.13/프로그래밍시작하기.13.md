# 객체지향 프로그래밍
## 절차형 프로그래밍이란 ##
프로그래밍에도 철학이 있습니다. 지금까지 우리가 했던 접근법을 절차형 프로그래밍이라고 부릅니다. for 반복문, if 조건문을 구성해서 우리가 원하는 프로그램을 작성하는 것에 익숙해졌습니다. 하지만 이런 방법을 계속 유지하면 곧 불편함을 느끼게 됩니다. 어떤 경우가 그럴까요? 사례를 통해 알아봅시다.
### 절차형 프로그래밍으로 물고기 묘사하기 ###
noise() 함수를 이용해 연못 속 물고기의 움직임을 모사해봅시다.

	//myFish
	float xoff = random(1000);
	float yoff = random(1000);
	float step = 0.01;
	float radius = 30;
	
	void setup() {
		size(480, 360);
		smooth();
		ellipseMode(RADIUS);
	}
	
	void draw() {
		float posX = map(noise(xoff), 0, 1, 0, width);
		float posY = map(noise(yoff), 0, 1, 0, height);
		
		background(255);
		strokeWeight(5);
		ellipse(posX, posY, radius, radius);
		
		xoff = xoff + 0.01;
		yoff = yoff + 0.01;
	}

![](http://i.imgur.com/kfqs55Z.jpg)

좀 더 힘좋은 잉어를 보시고 싶으시면 step 변수값을 늘이세요. 그렇게 하면 noise() 함수값의 변화가 더 커져 움직임이 빨라집니다.

반대로 평온한 움직임을 보고 싶으시면 step값을 줄이세요.

#### 잉어 한 마리 추가합니다 ####
한 마리 더 그려볼까요? 어떻게 하면 될까요?
	
	//myTwoFishes
	float x1off = random(1000);
	float y1off = random(1000);
	float step1 = 0.01;
	float radius1 = 30;
	
	float x2off = random(1000);
	float y2off = random(1000);
	float step2 = 0.005;
	float radius2 = 50;
	
	void setup() {
		size(480, 360);
		smooth();
		ellipseMode(RADIUS);
	}
	
	void draw() {
		float posX1 = map(noise(x1off), 0, 1, 0, width);
		float posY1 = map(noise(y1off), 0, 1, 0, height);
	
		float posX2 = map(noise(x2off), 0, 1, 0, width);
		float posY2 = map(noise(y2off), 0, 1, 0, height);
	
		background(255);
		//fish1
		strokeWeight(5);
		ellipse(posX1, posY1, radius1, radius1);
	
		//fish2
		strokeWeight(10);
		ellipse(posX2, posY2, radius2, radius2);
		
		x1off = x1off + step1;
		y1off = y1off + step1;
	
		x2off = x2off + step2;
		y2off = y2off + step2;
	}
![](http://i.imgur.com/QEBceg3.jpg)

#### 잉어 세 마리 ####
다시 한 마리 더 추가해서 세 마리를 그려보려고 합시다. 변수들을 한 묶음 더 정의해야 하고 이것 저것 부가적인 작업이 잔뜩 필요합니다.

한 마리를 추가할 때마다 코드는 몇 줄씩 늘어나고 변수를 제대로 관리하는 것이 점점 힘들어집니다. 정말 이런 방법 밖에 없을까요? 이게 최선인가요? 

우리는 이미 함수를 이용해 반복되는 코드를 묶는 법을 살펴보았습니다. 반복문을 이용해서 복잡한 도형을 간단히 처리하는 법을 연습했습니다. 새로운 방법이 등장할 때마다 이해하고 익숙해지는데 많은 품이 듭니다. 하지만 품을 들일 가치가 있는 경우가 대부분입니다. 이제 새로운 개념과 기술을 익혀 이 문제를 더 바람직하게 프로그래머처럼 풀어봅시다.

## 객체지향 프로그래밍  ##
지금까지 우리가 한 프로그래밍 방식을 절차형 프로그래밍(Procedural Programming)이라고 지칭합니다. 지금까지의 문제해결이란 주어진 데이터 혹은 변수를 어떻게 처리하는지 규칙을 컴퓨터에게 알려주는 것을 지칭했습니다. if 문을 사용해 조건에 따라 변수처리가 달라지기도 하고 for 반복문을 사용해 반복되어 구문을 실행하기도 하는 등 주어진 데이터를 어떻게 처리할 것인지 프로그래머가 모든 권한을 가지고 세세한 부분까지 신경을 써야 합니다.

### 객체지향 프로그래밍은 객체 간의 메세지 교환이 중요합니다 ###
이와는 다르게 객체지향 프로그래밍은 전체 프로그램을 작은 객체의 모임으로 이해합니다. 객체는 자율성을 가지고 동작하기 때문에 프로그래머가 세세한 부분까지 신경쓸 필요가 없습니다. 객체에게 메세지를 전달하면 객체가 알아서 해석할 뿐 객체가 실제로 어떻게 동작하는지 신경쓰지 않고 객체를 믿고 맡깁니다.

실제 코드를 보면서 이야기해 볼까요? fish라는 객체가 있습니다. 매 프레임마다 "움직여라"는 메세지를 fish에게 전달합니다. 그리고 객체 자신의 위치를 "표시하라"는 메세지를 전합니다. 아마 아래와 같은 모습을 띌 것입니다. 

	fish.move();
	fish.display();

우리가 이전에 작성한 코드와 비교해보세요. 어떤가요? 절차형 프로그래밍이라고 말했던 코드에서는 아래처럼 fish의 위치를 일일이 지정하고 매번 우리가 화면에 위치를 그리라는 명령을 내려야 하는 것과 차이가 있습니다.

	float posX = map(noise(xoff), 0, 1, 0, width);
	float posY = map(noise(yoff), 0, 1, 0, height);
	
	ellipse(posX, posY, radius, radius);

어떻게 보면 객체지향 프로그래밍은 프로그래머에게 더 큰 역할과 권한을 주는 것처럼 느껴집니다. 도형 하나하나가 어떻게 움직이는지 세세한 부분까지 신경써야 하는 실무진이 아니라 전화나 이메일로 일하는 높으신 분들이 되어 객체에게 메세지를 전달하고 객체는 그 메세지를 자율적으로 처리하는 식으로 프로그래머의 역할이 바뀌는 것입니다.

### 캡슐화 ###
객체지향 프로그래밍의 또 다른 장점은 캡슐화입니다. fish 객체는 자신의 위치를 저장하는 변수를 가지고 있을 테지만 객체 내부에 변수를 품고 있을 뿐 변수를 바깥에 드러내지 않습니다. 

posX와 posY 변수를 일일이 설정할 필요없이 객체가 필요로 하는 변수를 객체가 모두 캡슐화해서 가지고 있다면 다루기가 쉬워집니다.

posX1, posY1, posX2, posY2를 일일이 설정할 필요없이 아래와 같은 코드로 간단히 처리할 수 있는 것입니다.

	fish1.move();
	fish1.display();
	
	fish2.move();
	fish2.display();

이런 식으로 접근하면 세 마리가 무엇이랍니까? n마리도 처리할 수 있을 것 같습니다.

## 클래스란? ##
지금까지 객체의 특성과 객체를 이용해 프로그램을 하면 어떤 이점이 있는지 살펴보았습니다. 이제 객체지향 프로그래밍을 실제로 해 볼 차례입니다. 객체지향을 지원하는 프로그래밍 언어는 각자 다른 방식으로 객체를 구현합니다. 프로세싱은(프로세싱의 기반이 되는 자바도 마찬가지로) 클래스를 이용해 객체를 구현합니다.

거칠게 말해 클래스는 객체를 찍어내는 붕어빵 틀과 같습니다. 객체가 주어진 메세지에 어떻게 반응하고 다른 객체와 어떻게 협력하는지가 서술된 명세서와 같은 역할을 합니다. 프로세싱에서 객체의 구현은 클래스를 선언하는 것에서 시작합니다.

코드를 먼저 접한 다음 이야기를 계속 이어갑시다.

	//myFirstFishClass
	class Fish {
		float posX = random(0, width);
		float posY = random(0, height);
	
		float xoff = random(1000);
		float yoff = random(1000);
		
		float step = 0.01;
		float radius = 30;
	
		Fish() {
	}

	void move() {
		posX = map(noise(xoff), 0, 1, 0, width);
		posY = map(noise(yoff), 0, 1, 0, height);
		xoff = xoff + step;
		yoff = yoff + step;
	}

	void display() {
		strokeWeight(5);
		ellipseMode(RADIUS);
		ellipse(posX, posY, radius, radius);
	}
}

	Fish fish;
	
	void setup() {
		size(480, 360);
		fish = new Fish();
	}
	
	void draw() {
		background(255);
		fish.move();
		fish.display();
	}

![](http://i.imgur.com/LtzmBgo.jpg)

전혀 다른 방식으로 같은 결과를 얻었습니다. 이제 우리가 무슨 짓을 한 건지 하나씩 따져봅시다.

### class 선언 ###
가장 먼저 눈에 띄는 것은 class라는 키워드입니다. class라는 키워드 다음에 위치하는 것이 지금 정의하는 클래스의 이름입니다. 

	class Fish {
		...
	}

위의 구문은 Fish라는 클래스를 {...} 에서 정의하겠다는 의미입니다. 관용적으로 클래스의 이름은 대문자로 시작합니다. 앞으로 대문자로 시작하는 이름이 나오면 클래스가 아닌지 생각해보세요. 많은 경우 그럴 것입니다.

사실 여러분들은 이미 클래스를 여러 번 접했습니다. 이미지를 다룰 때 PImage도 클래스입니다.  도형을 다룰 때 사용한 PShape도 클래스입니다. 문자열 String도 클래스입니다. 이번 시간은 지금까지 알게 모르게 사용했던 객체지향 프로그래밍에 대해 자세히 알아보는 시간입니다.

### 클래스와 객체의 차이 ###
앞서 이야기한 것처럼 클래스는 붕어빵을 찍어내는 틀에 불과합니다. 붕어빵을 먹으려면 틀을 이용해 붕어빵을 찍어내야 합니다. 클래스는 붕어빵 틀과 같고 붕어빵은 객체에 해당합니다.

클래스에서 객체를 생성하려면 특별한 함수를 사용합니다. 이 함수를 클래스이 생성자(constructor)라고 합니다. 어떻게 사용하는지 더 살펴볼까요?

클래스 정의를 살펴보니 Fish() 함수라는 것이 있습니다.

유심히 살펴보면 일반적인 함수와 모습이 다른 점이 있습니다. 우선 클래스 이름 Fish와 Fish()는 같은 이름을 사용합니다. 그리고 Fish()는 반환형(return type)을 가지고 있지 않습니다. 이런 함수를 생성자(constructor)라고 부릅니다. 명칭에서 유추할 수 있듯이 객체를 만들 때 사용하는 함수입니다.

객체의 생성은 다음과 같은 문법을 따릅니다.

	Fish fish = new Fish();

사실 이런 문법은 배열을 선언할 때 이미 접한 적이 있습니다. 정수 다섯 개를 원소로 가지는 배열을 선언할 때 아래과 같이 실행한 것을 기억하실 것입니다.

	int[] integers = new int[5];

생성자 Fish()가 int[5] 대신 사용되었을 뿐 동일한 문법이라는 것을 금방 확인할 수 있습니다.

Fish() 생성자가 실행되면 Fish() {...} 블록 내부의 구문이 실행됩니다. fish 객체가 생성되면서 객체가 사용할 멤버변수가 모두 생성됩니다. 비어있는 Fish() 생성자는 특별한 일을 하지 않습니다.

	Fish() {
	}

### 멤버변수 ###
class Fish {...} 블록 안을 보시면 낯익은 변수이름들이 보입니다. posX, posY, xoff, yoff, step, radius와 같은 변수는 Fish 클래스에 의해 생성된 각각의 객체가 사용할 고유의 변수입니다. 멤버변수라고 부르기도 합니다. 

	float posX = random(0, width);
	float posY = random(0, height);
	
	float xoff = random(1000);
	float yoff = random(1000);
		
	float step = 0.01;
	float radius = 30;

### 멤버함수 혹은 메소드 ###
생성자 Fish()의 정의 다음으로 멤버함수의 정의가 따릅니다. 메소드라고 부르기도 하는 멤버함수는 객체가 어떤 메세지를 받을 때 어떤 행동을 하는지를 정의합니다.

	void move() {
		posX = map(noise(xoff), 0, 1, 0, width);
		posY = map(noise(yoff), 0, 1, 0, height);
		xoff = xoff + step;
		yoff = yoff + step;
	}

fish에게 '움직여라'는 메시지를 아래와 같이 전합니다.

	fish.move();

그러면 fish 객체는 move() 메서드 내부에 정의된 행동을 합니다. move() 메서드는 fish 객체의 posX, posY, xoff, yoff를 업데이트 합니다.

move() 메서드 다음으로 display() 메서드가 정의됩니다.

fish에게 '지금 있는 위치를 나타내라'라는 메시지를 아래와 같이 전합니다.

	fish.display();

그려면 fish 객체는 원으로 자신의 위치를 나타냅니다.

	void display() {
		strokeWeight(5);
		ellipseMode(RADIUS);
		ellipse(posX, posY, radius, radius);
	}

### 여러 개의 객체 사용하기 ###
이제 여러 마리를 그려볼까요? 객체지향 프로그래밍이 정말 코드를 간결하게 유지할 수 있도록 도움을 줄까요?

	//myFishClassMultipleInstances
	class Fish {
		float posX = random(0, width);
		float posY = random(0, height);
	
		float xoff = random(1000);
		float yoff = random(1000);
		
		float step = 0.01;
		float radius = 30;
	
		Fish() {
		}
	
		void move() {
			posX = map(noise(xoff), 0, 1, 0, width);
			posY = map(noise(yoff), 0, 1, 0, height);
			xoff = xoff + step;
			yoff = yoff + step;
		}
	
		void display() {
			strokeWeight(5);
			ellipseMode(RADIUS);
			ellipse(posX, posY, radius, radius);
		}
	}
	
	Fish fish1;
	Fish fish2;
	Fish fish3;
	
	void setup() {
		size(480, 360);
		fish1 = new Fish();
		fish2 = new Fish();
		fish3 = new Fish();
	}
	
	void draw() {
		background(255);
	
		fish1.move();
		fish1.display();
	
		fish2.move();
		fish2.display();
	
		fish3.move();
		fish3.display();
	
	}

![](http://i.imgur.com/LbRWuVu.jpg)

도움이 되는 것 같습니다. Fish 클래스를 활용하니 여러 객체를 손쉽게 만들고 이용할 수 있습니다.

### class 정의를 다른 파일로 떼어내기 ###
이제 새로운 기능이 필요할 때면 클래스 정의를 수정하는 것으로 충분합니다. setup() 함수나 draw() 함수는 큰 변화가 없는 반면 클래스 정의는 자꾸만 길어집니다. 이렇게 되면 나중에 코드를 읽기가 힘듭니다. 코드를 간결하게 유지하고 싶지만 길어지는 클래스 정의가 고민입니다. 어떻게 해야 할까요?

클래스 정의를 다른 파일로 떼어냅시다. 단축키 Ctrl + Shift + N을 누르거나 현재 편집창 오른쪽의 삼각형을 클릭해 새 탭을 클릭하세요.

새 탭의 이름은 클래스의 이름으로 합니다. 새 탭의 이름은 클래스 이름과 동일하게 합시다.

이제 원래 탭으로 돌아가 다시 프로그램을 실행합니다. 이전과 동일하게 움직이는 프로그램을 확인하셨나요? `Ctrl + K`를 눌러 현재 프로그램의 폴더를 열어 보세요. 원래 파일에 추가해  Fish.pde 파일이 저장되어 있는 것을 확인할 수 있습니다. 이런 식으로 클래스 정의 파일을 분리해서 작업하는 것을 추천합니다.

![](http://i.imgur.com/aIjUc9L.png)
![](http://i.imgur.com/REa9uGZ.png)

## 클래스의 예 ##
객체지향 프로그래밍을 처음 접하면서 우선 우리가 원하는 기능을 가진 클래스를 정의하는 것을 배웠습니다. 이제 객체지향 프로그래밍이 무언지 조금 알 것 같습니다.

그런데 사실 우리가 새로운 클래스를 처음부터 만드는 경우는 많지 않습니다. 클래스를 새로 정의하는 일보다는 다른 사람이 만들어 놓은 클래스를 활용하는 경우가 더 많습니다. 그리고 이미 여러분들은 다른 사람이 만들어 놓은 클래스를 사용해 왔습니다. 그런 클래스가 어떤 것들이 있는지 살펴보고 좀 더 깊은 이야기를 나눠봅시다.
### String 클래스 ###
문자열을 사용할 때 등장했던 String 타입은 사실 String 클래스입니다.

	String str = "This is String Type.";
	println(str);

위의 구문은 아래와 같이 고쳐쓸 수 있습니다.

	String str = new String("This is String Type.");
	println(str);

toUpperCase()나 length()는 String 클래스의 메서드입니다.

	String str = new String("This is String class style!.");
	println(str);
	println(str.toUpperCase());
	println(str.length());

### PImage 클래스 ###
이미지를 다룰 때 사용했던 PImage 타입도 사실 PImage 클래스입니다.

PImage 클래스는 pixels[] 배열과 width 그리고 height를 멤버변수로 가지고 있고 get(), filter()와 같은 메소드를 가지고 있습니다. 

단 `PImage img = new PImage()`처럼 클래스의 생성자로 PImage를 만드는 것은 권장하지 않습니다. 이미지를 불러들일 때는 언제나 loadImage()함수를 사용하세요. 아래 예제 결과를 확인하고 콘솔창의 출력도 함께 보세요.

	//myPImage
	PImage img;
	void setup() {
		size(100, 200);
		img = loadImage("https://www.processing.org/reference/images/PImage.png");
		println("image width: " + img.width);
		println("image height: " + img.height);

		image(img,0, 0, width, 100);
		image(img.get(0, 50, width, 50), 0, 100, width, 50);
		img.filter(BLUR, 6);
		image(img.get(0, 50, width, 50), 0, 150, width, 50);
	
	}

![](http://i.imgur.com/YflGOxD.jpg)
![](http://i.imgur.com/C3pMPhC.png)

이 외에도 프로세싱은 사용자가 유용하게 사용할 수 있는 클래스를 많이 가지고 있습니다. 폰트와 관련된 PFont, SVG 이미지 파일과 관련된 PShape 등 여러 기능이 클래스를 통해서 구현되어 있습니다.

## ArrayList 클래스: 객체 묶음 다루기 ##
객체를 다루다 보면 여러 개의 객체 묶음을 관리해야 할 때가 있습니다. 이런 때 첫번째로 생각해 볼 해법은 배열의 사용입니다.

### 객체 배열 ###
예를 들어 평면 위의 위치를 기록하기 위해 다음과 같이 Point 클래스를 정의했다고 합시다.

	class Point {
		float x;
		float y;
		
		Point() {
			this.x = random(width);
			this.y = random(height);
		}
	}

Point 클래스 배열을 정의하려면 다음과 같이 코드를 작성합니다. points 배열의 인덱스를 통해 각 객체에 접근할 수 있습니다.

	Point[] points;
	void setup() {
		points = new Point[5];
		for (int i = 0; i < points.length; i++) {
			points[i] = new Point();
		}
	
		for (int i =0; i < points.length; i++) {
			println("(" + points[i].x + ", " + points[i].y + ")");
		}
	}

객체 다섯 개를 배열 points에 담았습니다. for 반복문을 이용해 객체를 생성하고 객체에 접근했습니다. 이런 식으로 객체를 한 덩어리로 묶어서 사용할 수 있음을 알았습니다.

그런데 객체가 몇 개 필요한지 사전에 알고 있을 때는 배열을 사용할 수 있지만 사실 그런 경우는 드물지 않을까요? 예를 들어 마우스를 클릭할 때마다 Fish 객체를 추가한다고 하면 배열을 사용해서는 원하는 기능을 만족할 수 없습니다. 프로그램을 실행하기 전에 마우스 클릭을 몇 번을 할 지 알 수 없는 노릇입니다.

그래서 준비했습니다. ArrayList 클래스. ArrayList 클래스를 활용하면 프로그램이 동작하는 중에 새로운 원소를 계속 추가할 수 있습니다.

### 크기를 바꿀 수 있는 ArrayList ###
ArrayList는 프로세싱 프로그래밍을 할 때 요긴하게 자주 사용되는 일종의 데이터 저장 관련 클래스입니다. 프로그램이 시작하기 전에 크기가 정해져야 하는 배열과는 다르게 ArrayList는 프로그램이 돌아가는 중에도 원소를 추가할 수 있습니다.

게다가 ArrayList 클래스는 쓸모많은 여러 메서드를 제공하기 때문에 매우 편리하게 사용할 수 있습니다.

ArrayList 클래스를 사용하는 방법을 살펴볼까요?

먼저 ArrayList 객체를 가리키는 변수를 선업합시다.

	ArrayList<Point> points;

ArrayList 다음의 <...> 사이에 ArrayList가 담고 있을 타입을 입력합니다. 우리는 Point 클래스의 객체를 담으려고 하니 <...> 사이에 Point를 입력합니다.

그리고 아래와 같이 setup() 함수 내부에서 ArrayList 객체를 생성합니다. <...>가 있어 조금 어색하지만 눈에 익지 않아 그럴 뿐 사용하다 보면 익숙해질 것 같습니다. 앞으로 ArrayList는 자주 등장하니 자연스럽게 익숙해질 것입니다.

	void setup() {
		...
		points = new ArrayList<Point>();
		...
	}

이제 ArrayList 클래스가 어떤 것인지 알았으니 실제 코드를 보며 ArrayList가 어떻게 사용되는지 살펴봅시다. 아래의 코드는 마우스 왼쪽 버튼을 클릭을 하면 마우스 포인터 위치에 원이 생기고 마우스 오른쪽 버튼을 클릭하면 마지막 원이 사라지는 작은 프로그램입니다.

	//myArrayList
	class Point {
		float x;
		float y;
		
		Point() {
			this.x = mouseX;
			this.y = mouseY;
		}
		
		void display() {
			strokeWeight(5);
			ellipseMode(RADIUS);
			ellipse(this.x, this.y, 30, 30);
		}
	}
	
	ArrayList<Point> points;
	void setup() {
		size(480, 360);
		points = new ArrayList<Point>();
	}
		
	void draw() {
		background(255);
		for (int i = points.size() - 1 ; i > 0; i--) {
			Point p = points.get(i);
			p.display();
		}
	}
	
	void mousePressed() {
		if (mouseButton == LEFT) {
			points.add(new Point());
		}
		else if (mouseButton == RIGHT && (!points.isEmpty())) {
			points.remove(points.size() - 1);
		}
	}

![](http://i.imgur.com/CgMFeD3.jpg)

먼저 눈에 띄는 것은 draw() 함수 내부의 for 반복문입니다. for 반복문은 ArrayList 객체 points를 거꾸로 순회하며 points.get(i)를 실행합니다. points.size()는 points 객체의 길이를 구합니다. 인덱스가 0부터 시작하니 points 객체의 마지막 원소의 인덱스는 points.size() - 1 이 됩니다. 

ArrayList의 메서드 get(i)는 인덱스 i에 해당하는 원소를 찾아줍니다. 그리고 이 원소(Point 객체를)를 p에 할당합니다. 그리고 Point 객체 p의 메서드 display()를 실행합니다.

마우스를 클릭하면 마우스 관련 이벤트 핸들러 mousePressed() 함수 내부의 구문이 실행됩니다.

왼쪽 버튼이 클릭되면 points.add(new Point()) 구문을 통해 Point 객체가 points의 마지막에 추가됩니다.

반대로 오른쪽 버튼이 클릭되면 points 가 비어있지 않을 때만(!points.isEmpty()) points 객체의 꼬리쪽 마지막 원소를 제거합니다(points.remove(points.size() - 1).

어떻습니까? ArrayList 어렵지 않지요? 

### Walker 클래스 ###
random() 함수와 noise() 함수를 설명하며 화면을 배회하는 도형을 그린 적이 있습니다. 이제 같은 행동을 하는 도형을 객체로 구현해 봅시다.
#### 화면을 배회하는 Walker 클래스: 균등분포 ####
거창하게 들리지만 사실 뭐 별 거 없습니다. Walker 클래스를 만들어 봅시다. Walker 객체는 세 가지 메세지를 제대로 처리하면 됩니다. 첫번째가 생성자, 두번째는 다음 지점으로 이동하라는 walk(), 그리고 마지막으로 화면에 자신의 지점을 표시하라는 display()를 잘 처리하는 클래스를 정의하면 됩니다. 실제로 어떻게 처리될는지 클래스를 정의하기 전에 먼저 적어봅시다.

	Walker walker = new Walker();
	walker.walk();
	walker.display();

어떤 행동을 해야 하는지 명확해졌으니 Walker 클래스를 정의해봅시다.

	//myWalker
	class Walker {
		float posX;
		float posY;
		float stepSize = 5.0;
		
		Walker() {
			posX = random(width);
			posY = random(height);
		}
	
		void walk() {
			float r = random(1);
			if (r < 0.25) {
				posX = posX - stepSize;
			}
			else if (r < 0.5) {
				posX = posX + stepSize;
			}
			else if (r < 0.75) {
				posY = posY - stepSize;
			}
			else {
				posY = posY + stepSize;
			}
				
			posX = constrain(posX, 0, width);
			posY = constrain(posY, 0, height);
		}
	
		void display() {
			strokeWeight(5);
			stroke(0, 50);
			point(posX, posY);
		}
	}
	
	Walker walker;
	void setup() {
		size(480, 360);
		smooth();
		background(255);
		frameRate(240);
	
		walker = new Walker();
	}
	
	void draw() {
		walker.walk();
		walker.display();
	}

![](http://i.imgur.com/h1YGRNf.jpg)
![](http://i.imgur.com/icpKIoK.jpg)

walker객체는 각각 1/4 확률로 위, 아래, 왼쪽, 오른쪽 중 한 방향으로 이동합니다. display() 메서드에 투명도를 적용해 자주 방문할수록 색이 진해지는 것을 관찰할 수 있습니다.

#### 화면을 배회하는 Walker 클래스: 가우시안 분포 ####
균등분포 Walker 객체는 위/아래/왼쪽/오른쪽으로 움직일 확률이 0.25로 동일합니다. 하지만 이런 경우는 굉장히 예외적인 상황입니다. 균등분포 대신 정규분포(가우시안분포)를 사용해 Walker 클래스를 재정의합시다.

수정할 부분은 walk() 메서드입니다. 다음 위치를 업데이트 하는 부분만 간단히 수정합니다.

	//myWalkerGaussian
	class Walker {
		float posX;
		float posY;
		float sigma = 5.0;
		
		Walker() {
			posX = random(width);
			posY = random(height);
		}
	
		void walk() {
			posX = posX + sigma * randomGaussian();
			posY = posY + sigma * randomGaussian();
		
			posX = constrain(posX, 0, width);
			posY = constrain(posY, 0, height);
		}
	
		void display() {
			strokeWeight(5);
			stroke(0, 50);
			point(posX, posY);
		}
	}
	
	Walker walker;
	void setup() {
		size(480, 360);
		smooth();
		background(255);
		frameRate(240);
	
		walker = new Walker();
	}
	
	void draw() {
		walker.walk();
		walker.display();
	}

![](http://i.imgur.com/31DnCLj.jpg)
![](http://i.imgur.com/Qmk2s7C.jpg)

#### 화면을 배회하는 Walker 클래스: noise() 함수 ####
noise() 함수를 사용하면 어떨까요? 코드를 조금만 수정해서 noise() 함수를 따라 이동하는 모습을 확인해 봅시다.

	//myWalkerNoise
	class Walker {
		float posX;
		float posY;
		float stepSize = 1.0;
		float xoff = random(1000);
		float yoff = random(1000);
		
		Walker() {
			posX = random(width);
			posY = random(height);
		}
	
		void walk() {
			posX = posX + map(noise(xoff), 0, 1, -stepSize, stepSize);
			posY = posY + map(noise(yoff), 0, 1, -stepSize, stepSize);
		
			posX = constrain(posX, 0, width);
			posY = constrain(posY, 0, height);
	
			xoff = xoff + 0.01;
			yoff = yoff + 0.01;
		}
	
		void display() {
			strokeWeight(5);
			stroke(0, 50);
			point(posX, posY);
		}
	}
	
	Walker walker;
	void setup() {
		size(480, 360);
		smooth();
		background(255);
		
		walker = new Walker();
	}
	
	void draw() {
		walker.walk();
		walker.display();
	}

![](http://i.imgur.com/X9cVQKO.jpg)
![](http://i.imgur.com/9Fpg8Sz.jpg)

# PVector와 운동 #
## PVector ##
지금까지 화면 위의 지점을 특정하는 여러 방법을 살펴봤습니다. (posX, posY)처럼 두 개의 변수를 따로 사용하는 법을 제일 먼저 살펴보았습니다. 

객체지향 프로그래밍을 배운 이후  posX와 posY를 Point 클래스의 멤버변수로 사용하는 방법을 알아보았고 이 방법을 활용해 Fish 클래스나 Walker 클래스에도 동일하게 적용했습니다.

이제 화면 위의 위치를 특정하는 세 번째 방법을 알아볼 차례입니다. 프로세싱은 PVector 클래스를 기본으로 제공합니다. PVector는 2차원이나 3차원에서의 위치를 지정하는데 편리하며 속도나 가속도 그리고 움직이는 방향 등을 계산하는데 편리한 많은 메소드를 제공합니다. 워낙 많이 사용되는 클래스라서 인터넷에서 찾을 수 있는 많은 프로세싱 작업에 빠지지 않고 등장하고 있습니다. 이번 기회를 PVector 클래스에 익숙해지는 기회로 삼아봅시다.

### PVector 객체 생성과 멤버변수 ###
PVector 클래스는 x, y, z 세 개의 멤버변수를 가집니다. 평면에 도형을 표현한다면 z를 사용할 필요는 없습니다.

일반적인 클래스 사용법을 따라 새로운 PVector 객체를 만들어 봅시다. 

	PVector walker;
	
	void setup() {
		size(480, 360);
		background(255);
		walker = new PVector(100, 200);
	
		strokeWeight(5);
		ellipse(walker.x, walker.y, 30, 30);
	}

### PVector를 멤버변수로 가지는 Point 클래스 ###
PVector는 단독으로 쓰이기 보다는 다른 클래스의 멤버변수로 사용되는 경우가 많습니다. 예를 들어 이전에 정의했던 Point 클래스를 PVector 클래스를 활용해 다시 정의해 봅시다.

	//myPVecorStatic
	class Point {
		PVector location;
		
		Point() {
			location = new PVector(width / 2, height / 2);
		}
	
		void display() {
			strokeWeight(5);
			ellipse(location.x, location.y, 30, 30);
		}
	}
	
	Point point;
	void setup() {
		size(480, 360);
		smooth();
		background(255);
		point = new Point();
	}

	void draw() {
		point.display();
	}

![](http://i.imgur.com/Bx1kDGD.jpg)

### Pvector의 메서드 add() ###
PVector 객체는 서로 더할 수 있습니다. add() 메서드를 사용하면 PVector 객체끼리 깔끔하게 더할 수 있습니다. 원래 위치 original은 흰 색으로 칠해져 있습니다. original.add(movement)를 실행해 original과 movement를 더한 새로운 위치가 회색 원으로 표시되고 있습니다.

	//myPVectorAdd
	PVector origin;
	PVector movement;
	
	void setup() {
		size(480, 360);
		smooth();
		background(255);
		
		origin = new PVector(120, 120);
		movement = new PVector(120, 120);
		
		strokeWeight(5);
		
		noFill();
		ellipse(origin.x, origin.y, 30, 30);
		
		origin.add(movement);
		
		fill(100, 100);
		ellipse(origin.x, origin.y, 30, 30);
	}

![](http://i.imgur.com/lQhmX3G.jpg)

#### add()를 활용해 등속운동 표현하기 ####
등속운동이라는 말은 너무 거창합니다. 한자어에 두려워 마세요. 등속운동은 같은 속도로 움직이는 운동을 말합니다. 얼음 위를 미끄러지는 물체를 생각해 보세요. 그래비티 같은 영화에서 주인공이 우주를 유영할 때 보여주는 움직임을 생각해 보세요. 천천히 같은 방향을 향해 같은 속도로 움직이는 경우 등속운동을 한다고 말합니다.

프로세싱에서 등속운동을 어떻게 표현할 수 있을까요? 등속운동을 하는 도형의 위치는 프레임마다 바뀝니다. 매 프레임마다 PVector 객체 velocity를 location 객체에 더하는 것은 어떻까요? 매 프레임마다 velocity만큼 이동하는 것이지요.

아래 코드 중 핵심은 move() 메서드 안의 `location.add(velocity);` 입니다. move()가 메세지를 처리할 때마다 현재 위치 location에 velocity 객체를 더해 갑니다. 

	//myPVectorAddConstantVelocity
	class Point {
		PVector location;
		PVector velocity;
		float radius = 30;
		
		Point() {
			location = new PVector(width / 2, height / 2);
			velocity = new PVector(random(5), random(5));
		}
	
		void move() {
			location.add(velocity);
	
			//오른쪽 벽을 넘어가면
			if (location.x > width + radius) {
				location.x = 0;
			}
			//왼쪽 벽을 넘어가면
			else if (location.x < 0 - radius) {
				location.x = width;
			}
			//아래쪽 바닥을 넘어가면
			if (location.y > height + radius) {
				location.y = 0;
			}
			//위쪽 천장을 넘어가면
			else if (location.y < 0 - radius) {
				location.y = height;
			}
		}
	
		void display() {
			strokeWeight(5);
			ellipseMode(RADIUS);
			ellipse(location.x, location.y, radius, radius);
		}
	}
	
	Point point;
	void setup() {
		size(480, 360);
		smooth();
		background(255);
		point = new Point();
	}
	
	void draw() {
		background(255);
		point.move();
		point.display();
	}

![](http://i.imgur.com/5RAJAKf.jpg)
![](http://i.imgur.com/O4xmmky.jpg)

혹은 원이 화면 안에서 움직이도록 move() 메서드를 수정할 수도 있습니다. 원이 화면 가장자리에 닿이면 당구대에 공이 튕기듯 원이 반대방향으로 움직이도록 수정합니다. 무언가 복잡해 보이지만 사실 별 것 아닙니다. velocity의 부호를 반대로 바꾸는 것이 핵심 아이디어입니다.  이렇게 처리하면 원이 탱탱 볼처럼 사방으로 튀기는 것처럼 보입니다. 

	//myPVectorAddConstantVelocityBounce
	class Point {
		PVector location;
		PVector velocity;
		float radius = 30;
		
		Point() {
			location = new PVector(width / 2, height / 2);
			velocity = new PVector(random(10), random(10));
		}
	
		void move() {
			location.add(velocity);
	
			//오른쪽 벽에 닿이면
			if (location.x > width - radius) {
				velocity.x = - velocity.x;
			}
			//왼쪽 벽에 닿이면
			else if (location.x < 0 + radius) {
				velocity.x = - velocity.x;
			}
			//아래쪽 바닥에 닿이면
			if (location.y > height - radius) {
				velocity.y = - velocity.y;
			}
			//위쪽 천장에 닿이면
			else if (location.y < 0 + radius) {
				velocity.y = - velocity.y;
			}
		}
	
		void display() {
			strokeWeight(5);
			ellipseMode(RADIUS);
			ellipse(location.x, location.y, radius, radius);
		}
	}
	
	Point point;
	void setup() {
		size(480, 360);
		smooth();
		background(255);
		point = new Point();
	}
	
	void draw() {
		background(255);
		point.move();
		point.display();
	}

![](http://i.imgur.com/bvE6DFK.jpg)
![](http://i.imgur.com/nFP1KSI.jpg)
![](http://i.imgur.com/cN2rBLp.jpg)
![](http://i.imgur.com/feMumXl.jpg)

어떤 것이 더 마음에 드세요?

#### add()를 활용해 가속도운동 표현하기 ####
등속운동은 특별한 경우입니다. 속도의 변화가 없는 움직이라는 것은 일상에서는 보기 힘든 경우이지요. 버스가 출발하면 속도가 빨라지고 정류장에 가까워지면 속도를 줄여야 합니다. 바람에 움직이는 깃발은 바람의 방향을 따라 이리로 저리로 휘날립니다. 이처럼 속도가 변화하는 운동을 가속도 운동이라고 합니다.

속도 velocity에 변화를 주려면 velocity에 acceleration을 더하면 됩니다. velocity는 다시 location에 더해져 위치의 변화를 표현합니다.

코드로 정리할까요?

	velocity.add(acceleration);
	location.add(velocity);

이렇게 acceleration, velocity 그리고 location을 더해가면 속도가 변화는 물체의 위치를 계산할 수 있습니다. 

아래의 코드에서 확인해 봅시다. acceleration을 (-0.1, 0)으로 정하면 도형이 왼쪽으로 힘을 받게 됩니다. 왼쪽으로 속도가 계속 붙으면 더 빠른 속도로 벽에서 튕기게 됩니다. 다시 왼쪽으로 가속을 받고... 결국 도형이 화면이 왼쪽에 치우쳐서 운동합니다.

	//myPVectorSkewed
	class Point {
		PVector location;
		PVector velocity;
		PVector acceleration;
		float radius = 30;
		
		Point() {
			location = new PVector(width / 2, height / 2);
			velocity = new PVector(random(10), random(10));
			acceleration = new PVector(-0.1, 0);
		}
	
		void move() {
			velocity.add(acceleration);
			location.add(velocity);
	
			//오른쪽 벽에 닿이면
			if (location.x > width - radius) {
				velocity.x = - velocity.x;
			}
			//왼쪽 벽에 닿이면
			else if (location.x < 0 + radius) {
				velocity.x = - velocity.x;
			}
			//아래쪽 바닥에 닿이면
			if (location.y > height - radius) {
				velocity.y = - velocity.y;
			}
			//위쪽 천장에 닿이면
			else if (location.y < 0 + radius) {
				velocity.y = - velocity.y;
			}
		}
	
		void display() {
			strokeWeight(5);
			ellipseMode(RADIUS);
			ellipse(location.x, location.y, radius, radius);
		}
	}
	
	Point point;
	void setup() {
		size(480, 360);
		smooth();
		background(255);
		point = new Point();
	}
	
	void draw() {
		background(255);
		point.move();
		point.display();
	}

#### random()로 가속도 정하기 ####
가속도가 늘 같을 필요도 없습니다. 임의의 가속도를 사용했을 때 도형이 어떤 움직임을 보일까요?

임의의 값을 가지는 PVector를 만들 때 PVector.random2D()를 사용하면 편리합니다.

	//myPVectorRandomAcceleration
	class Point {
		PVector location;
		PVector velocity;
		PVector acceleration;
		float radius = 30;
		
		Point() {
			location = new PVector(width / 2, height / 2);
			velocity = new PVector(0, 0);
			acceleration = PVector.random2D();
		}
	
		void move() {
			acceleration = PVector.random2D();
			velocity.add(acceleration);
			location.add(velocity);
	
			//오른쪽 벽에 닿이면
			if (location.x > width - radius) {
				velocity.x = - velocity.x;
			}
			//왼쪽 벽에 닿이면
			else if (location.x < 0 + radius) {
				velocity.x = - velocity.x;
			}
			//아래쪽 바닥에 닿이면
			if (location.y > height - radius) {
				velocity.y = - velocity.y;
			}
			//위쪽 천장에 닿이면
			else if (location.y < 0 + radius) {
				velocity.y = - velocity.y;
			}
		}
	
		void display() {
			strokeWeight(5);
			ellipseMode(RADIUS);
			ellipse(location.x, location.y, radius, radius);
			println("acceleration:" + acceleration.x + ", " + acceleration.y);
		}
	}
	
	Point point;
	void setup() {
		size(480, 360);
		smooth();
		background(255);
		point = new Point();
	}
	
	void draw() {
		background(255);
		point.move();
		point.display();
	}

지면으로 보는 것보다 코드를 실행해 보는 것이 더 큰 도움이 됩니다.



