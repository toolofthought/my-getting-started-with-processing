# 도형의 이동과 변형 #

## 도형의 이동 ##
우선 괜찮은 도형을 하나 그려봅시다. 너무 간단하지도 복잡하지도 않은 도형이면 좋겠습니다. 적당히 비대칭이어서 어떤 방향을 향하고 있는지 알 수 있었으면 좋겠습니다. 음... 테트리스 블록 어떤가요? 테트리스 블록을 그려보겠습니다.

	//myTetris
	void setup() {
		size(480, 360);
	}
	
	void draw() {
		background(255);

		beginShape();
		vertex(240, 180);
		vertex(240, 120);
		vertex(300, 120);
		vertex(300, 240);
		vertex(180, 240);
		vertex(180, 180);
		endShape(CLOSE);
	}

![](http://i.imgur.com/e8dW1ms.jpg)

### 도형 좌표를 이동하기 ##
이 도형을 이동시키고 싶습니다. 어떻게 해야 할까요? 도형을 정의할 때 상수값을 사용했으니 이 도형을 옮길 방법이 마땅치 않습니다. 적어도 지금까지 배운 내용에서는 뾰족한 수가 없습니다. 이전에는 변수를 이용해서 아래와 같은 코드를 작성한 적이 있기는 합니다만 지금 원하는 답은 아닙니다.

	//myTetrisRelativePosition
	void setup() {
		size(480, 360);
	}
	
	void draw() {
		background(255);

		beginShape();

		float step = 60;

		float posX = mouseX;
		float posY = mouseY;
		vertex(posX, posY);

		posY -= step;
		vertex(posX, posY);

		posX += step;
		vertex(posX, posY);

		posY += 2 * step;
		vertex(posX, posY);

		posX -= 2 * step;
		vertex(posX, posY);

		posY -= step;
		vertex(posX, posY);
		endShape(CLOSE);
	}

![](http://i.imgur.com/8yKzMoq.jpg)
### 좌표 체계 이동하기 ##
변수를 지정해서 옮기는 것이 유일한 방법일까요? 생각해보면 이 방법은 한계가 많습니다. 예를 들어 화면에 도형이 잔뜩있는 경우를 생각해봅시다. 만약 도형을 이동하고 싶다면 모든 도형의 위치를 변수로 연결해야 하고 이 변수를 이리저리 가공해야 합니다. 도형이 10개 정도 있다면 가능한 방법이지만 도형이 수천 개라면 포기하고 말겠습니다. 무언가 다른 방법이 필요합니다.

첫 시간에 프로세싱의 좌표체계에 대해 언급했습니다. 화면의 왼쪽 위가 (0, 0), 오른쪽 아래는 (width, height) 값을 가지게 됩니다.

복습도 할 겸 좌표 그리드를 한번 그려볼까요?

	//myCoordinateSystemGrid
	void setup() {
		size(480, 360);
	}
	
	int step = 20;
	void draw() {
		background(255);
		for (int y = 0; y <= height; y += step) {
			if(0 == (y % 100)) {
	      		strokeWeight(2);
	    	}
	    	else {
	      		strokeWeight(0.5);
	    	}
	    	line(0, y, width, y);
		}
		
		for (int x = 0; x <= width; x += step) {
			if(0 == (x % 100)) {
	      		strokeWeight(2);
	    	}
	    	else {
	      		strokeWeight(0.5);
	    	}
	    	line(x, 0, x, height);		
		}
		
		textSize(32);
		fill(0);
		text("(0, 0)", 0, 32);
		text("(480, 360)", width - 170 , height - 16);
	}
![](http://i.imgur.com/AJYJ10v.jpg)

좌표를 가만히 보고 있으니 아이디어가 떠오릅니다. 도형을 옮기는 대신 좌표 자체를 옮기는 것은 어떨까요? 종이 위에 그려진 그림을 이용하려고 할 때 새로 그리는 대신 종이 자체를 옆으로 이동하면 보는 사람 입장에서는 도형이 이동한 것과 같은 변화가 일어난 것입니다.

이와 마찬가지로 화면 위의 도형을 옮기는 대신 화면의 좌표 자체를 이동합시다.

좌표체계를 이용할 때는 translate() 함수를 사용합니다. translate() 함수는 원점을 새로 정하는 함수입니다. translate() 함수는 입력된 값을 새로운 원점으로 삼습니다.

위의 코드에 translate() 함수를 적용해볼까요?

	//myCoordinateSystemGridTranslate
	void setup() {
		size(480, 360);
	}
	
	int step = 20;
	void draw() {
		background(255);
		translate(width / 2.0, height / 2.0);
		for (int y = 0; y < height; y += step) {
			if(0 == (y % 100)) {
	      		strokeWeight(2);
	    	}
	    	else {
	      		strokeWeight(0.5);
	    	}
	    	line(0, y, width, y);
		}
		
		for (int x = 0; x < width; x += step) {
			if(0 == (x % 100)) {
	      		strokeWeight(2);
	    	}
	    	else {
	      		strokeWeight(0.5);
	    	}
	    	line(x, 0, x, height);		
		}
		
		textSize(32);
		fill(0);
		text("new (0, 0)", 0, 32);
		text("(480, 360)", width - 170 , height - 16);
	}

![](http://i.imgur.com/k3LCYlF.jpg)

tranlae(width / 2.0, height / 2.0) 구문을 실행해 좌표 자체를 이동시키니 좌표에 그렸던 그림들이 모두 함께 이동합니다.

translate() 함수의 효과는 누적됩니다. 간단한 예제를 실행해 보겠습니다.

	//myCoordinateSystemGridTranslateCumulative
	void setup() {
		size(480, 360);
	}
	
	int step = 20;
	void draw() {
		background(255);

		fill(0);
		textSize(32);
		text("old old (0, 0)", 0, 32);
		fill(0, 255, 0);
		ellipse(0, 0, 10, 10);

		translate(width / 2.0, height / 2.0);
		for (int y = 0; y <= height; y += step) {
			if(0 == (y % 100)) {
	      		strokeWeight(2);
	    	}
	    	else {
	      		strokeWeight(0.5);
	    	}
	    	line(0, y, width, y);
		}
		
		for (int x = 0; x <= width; x += step) {
			if(0 == (x % 100)) {
	      		strokeWeight(2);
	    	}
	    	else {
	      		strokeWeight(0.5);
	    	}
	    	line(x, 0, x, height);		
		}
		
		fill(0);
		textSize(32);
		text("old (0, 0)", 0, 32);
		text("(480, 360)", width - 170 , height - 16);
		fill(0, 0, 255);
		ellipse(0, 0, 10, 10);
		
		translate(50, 50);
		fill(0);
		text("new (0, 0)", 0, 32);
		fill(255, 0, 0);
		ellipse(0, 0, 10, 10);
	}

원점 (0, 0)에 원을 그리라는 명령은 동일하지만 translate() 함수의 효과가 누적되어 다른 위치에 원이 그려집니다.

![](http://i.imgur.com/Owq4GkW.jpg)

translate() 함수를 이용하면 도형의 이동을 쉽게 할 수 있습니다.

도형을 정의할 때 상수값을 사용해서 도형을 옮길 방법이 마땅치 않았던 경우를 기억하시나요? translate() 함수를 이용하면 이런 경우도 쉽게 다룰 수 있습니다.

	//myTetrisRevisit
	void setup() {
		size(480, 360);
	}
	
	void draw() {
		background(255);
		translate(mouseX - 240, mouseY - 180);

		beginShape();
		vertex(240, 180);
		vertex(240, 120);
		vertex(300, 120);
		vertex(300, 240);
		vertex(180, 240);
		vertex(180, 180);
		endShape(CLOSE);
	}

![](http://i.imgur.com/LJQLyjY.jpg)

## 도형의 확대 ##
### 도형 크기 바꾸기 ###
도형의 크기를 늘이거나 줄이는 
### 좌표 크기 바꾸기 ###
	//myMap
	
	PShape map;
	float posX;
	float posY;
	
	void setup() {
	  size(509, 717);
	  map = loadShape("Administrative_divisions_map_of_South_Korea.svg");
	}
	
	void draw() {
	  shape(map, 0, 0);
	
	}
	

[참조 링크](http://blog.dokenzy.com/archives/1143 "참조 링크")
에러 메시지만 봐서는 xml파일이 잘못 구성된것 같네요. strings_etc.xml 파일을 에디터로 열었다가 utf-8 로 다시 저장한번 해보세요~ ﻿
## 도형의 회전 ##
### 각도 ###
### 도형 회전하기 ###
### 좌표 체계 회전하기

## 톱니바퀴 회전하기 ##
### 정지되어 있는 톱니바퀴 그리기 ###
### 회전하는 톱니바퀴 그리기 ###