# 사인과 코사인 #
이번 시간에는 약간의 수학이 필요합니다. 수학이라고 말하는 순간 두려움에 떠는 사람이 있을 수도 있는데 괜찮습니다. 어디에서나 들을 수 있는 정말 당연한 이야기를 단지 수학이라는 이름으로 포장할 뿐입니다. 평범한 이야기로 들어주세요.

우리는 이전에 원운동을 하는 점을 그려본 적이 있습니다. `rotate()`함수를 연습하면 어떤 도현을 회전시킨 적이 있느데 기억이 나시나요? 복습차원에서 다시 한 번 코드를 작성해봅시다.

	//myCircleMovement
	
	float theta = 0.0;
	
	void setup() {
		size(480, 360);
		smooth();
		background(255);
	}
	
	void draw() {
		pushMatrix();
		translate(width / 2, height / 2);
		rotate(theta);
		ellipse(100, 0, 10, 10);
		popMatrix();
		theta += 0.05;
	}

화면 한가운데를 중심으로 작은 원이 원운동을 하면서 회전합니다. 하지만 이 방법이 회전하는 물체의 위치를 표현하는 유일한 방법은 아닙니다.

	//myCircleMovementDecomposition
	
	float theta = 0.0;
	
	void setup() {
		size(480, 360);
		smooth();
		background(255);
	}
	
	void draw() {
		translate(width / 2, height / 2);
		ellipse(100 * cos(theta) , 100 * sin(theta), 10, 10);
		theta += 0.05;
	}

`ellipse()` 내부를 보니 cos()함수와 sin()함수라는 어쩌면 들어본 것같은 하지만 익숙하지 않은 함수가 보입니다. 이번 주제는 이 두가지 함수에 익숙해지는 것이 목표입니다. 한 번 해봅시다.

## 사인 ##
사인함수는 말하자면 각도가 변할 때 y축 방향으로 움직이는 변화를 말합니다. 이 말을 이해하기 위해 놀이동산으로 가봅시다.

### 대관람차 ###

![](http://i.imgur.com/JbRW7K8.jpg)

[source](http://ttoontti0448.tistory.com/entry/09%EB%85%84%EB%8F%84-%EB%9A%B1%EB%9D%A0%EC%9D%98-%EC%9D%BC%EB%B3%B8-%EB%B0%A9%EB%AC%B8%EA%B8%B0-11%EC%9D%BC%EC%A7%B8)

놀이동산이 아니더라도 이런 관람차를 본 기억이 있을 것입니다. 이런 놀이기구를타 본 기억을 떠올려 봅시다. 한가운데서 관람차를 타면 원운동을 하면서 서서히 상승합니다.그러면 처음에는 위로 천천히 상승할 것입니다. 그러다가 지표면과 조금 멀어져 45도 정도 회전하면 빠르게 상승합니다.

지표면과 평행이 될 때(90도) 가장 빠르게 상승하고 계속해서 꼭대기로 갈 때면 상대적으로 천천히 상승합니다. 원운동이 다 그런 것 아니겠습니까?

그러다 꼭대기에 도착하면(180도) 다시 천천히 하강하다 다시 빠르게 내려옵니다. 지표면과 평행이 된 위치(290도)에서 가장 빠르게 하강하고 다시 하강속도가 느려져 원래 자리(360도)로 돌아옵니다.

원운동을 보지말고 수직방향으로의 움직임만 관찰해 봅시다. 회전하는 각도에 따라 달라지는 수직방향 위치를 sin함수라고 합니다. 한 번 코드로 작성해볼까요?

	//myCircleVerticalMovement
	
	float theta = 0.0;
	float y;
	
	void setup() {
		size(480, 360);
		smooth();
		background(255);
	}
	
	void draw() {
		background(255);
		pushMatrix();
		translate(width / 2, height / 2);
		rotate(theta);
		fill(100);
		ellipse(100, 0, 10, 10);
		y = screenY(100, 0);
		popMatrix();
		theta += 0.05;

		fill(255, 0, 0);
		ellipse(width / 2, y, 10, 10);
	}

	void keyPressed()
	{
		if (key == 's' || key == 'S') {
			saveFrame("myVerticalMovement####.png");
		}
	}

![](http://i.imgur.com/sY4K2oI.png)
![](http://i.imgur.com/LMrrUSA.png)

`screenY()`함수를 이용해서 수직방향 위치를 빼낸 결과입니다. 관람차가 회전할 때 각도가 변할 때 수직방향 위치를 나타내는 함수가 `sin()`함수입니다.

수직방향이 있다면 수평방향으로의 움직임도 있겠지요. 수평방향 움직임을 `cos()`라고 합니다.

## 코사인 ##
사인과 마찬가지로 코사인에 대해서 코드를 작성해 봅시다.

	//myCircleHorizontalMovement
	
	float theta = 0.0;
	float x;
	
	void setup() {
		size(480, 360);
		smooth();
		background(255);
	}
	
	void draw() {
		background(255);
		pushMatrix();
		translate(width / 2, height / 2);
		rotate(theta);
		fill(100);
		ellipse(100, 0, 10, 10);
		x = screenX(100, 0);
		popMatrix();
		theta += 0.05;

		fill(0, 255, 0);
		ellipse(x, height / 2, 10, 10);
	}

	void keyPressed()
	{
		if (key == 's' || key == 'S') {
			saveFrame("myHorizontalMovement####.png");
		}
	}

## 사인과 코사인 ##
이제 두 방향을 합쳐봅시다.

	//myCircleHorizontalVerticalMovement
	
	float theta = 0.0;
	float x;
	float y;
	
	void setup() {
		size(480, 360);
		smooth();
		background(255);
	}
	
	void draw() {
		background(255);

		//guideline
		noFill();
		ellipse(width / 2, height / 2, 200, 200);
		line(width / 2 - 100, height / 2, width / 2 + 100, height / 2);
		line(width / 2, height / 2 - 100, width / 2 , height / 2 + 100);

		//circular movement
		pushMatrix();
		translate(width / 2, height / 2);
		rotate(theta);
		fill(100);
		ellipse(100, 0, 10, 10);
		x = screenX(100, 0);
		y = screenY(100, 0);
		popMatrix();
		theta += 0.05;

		//vertical movement
		fill(255, 0, 0);
		ellipse(width / 2, y, 10, 10);

		//horizontal movement
		fill(0, 255, 0);
		ellipse(x, height / 2, 10, 10);

	}

	void keyPressed()
	{
		if (key == 's' || key == 'S') {
			saveFrame("myHorizontalVerticalMovement####.png");
		}
	}

![](http://i.imgur.com/KfZky2r.png)
![](http://i.imgur.com/6NkUNT9.png)

회색점은 원운동을 , 빨간 점은 수직운동(sin), 녹색점은 수평운동(cos)을 나타냅니다.

여러분 원운동을 나타내는 것이 이렇게 쉽습니다. `rotate()`에서 사인과 코사인을 뽑아냈다면 반대로 사인과 코사인을 합성해 원운동을 표현할 수도 있습니다. 이 방법이 우리가 `myCircularMovementDecomposition`에서 실습한 내용입니다.

정리하면 cos는 원운동의 수평방향위치, sin은 원운동의 수직방향위치를 구할 수 있는 함수입니다.

# 주기 신호(periodic signal) #
그런데 말입니다 관람차를 타고 한바퀴를 돌면 이후에 보는 풍광은 첫번째 바퀴와 동일합니다. 관람차가 계속 회전해도 위치는 이전에 한 번 위치했던 곳입니다. 같은 위치를 반복해서 방문하는 것이 원운동의 특징입니다.

이는 cos함수와 sin함수에도 마찬가지로 적용됩니다. `myHorizontalVerticalMovement`의 회색, 빨간색 그리고 녹색점은 같은 자리를 계속 반복하기만 합니다.

이렇게 주기적으로 반복되는 신호를 주기신호라고 합니다. cos, sin함수가 주기신호를 만드는 대표적인 함수입니다.

질문이 있습니다. 얼마만큼 회전해야 원래 자리로 돌아가나요? 관람차는 한바퀴(360도 혹은 2π)만큼 회전하면 원래의 위치로 돌아옵니다. 모든 주기함수가 다 이와 같을까요?
## 주파수(Frequency), 주기(period) 그리고 파장(wavelength) ##
위의 질문에 괜찮은 대답을 하기 위해서 사인함수와 코사인 함수를 좀 더 배워봅시다.
## 진폭(amplitude) ##
주기함수는 진폭을 가집니다. 거칠게 말해서 진폭이란 얼마나 크게 움직이는지를 말하는 수치입니다. 관람차에 비유하면 큰 관람차는 큰 진폭을 가집니다. 반대로 작은 진폭은 작은 관람차에 비유됩니다.

	//myAmplitude

	
	
	Wheel small;
	Wheel large;

	float theta = 0.0;
	
	void setup() {
		size(960, 360);
		smooth();
		small = new Wheel(960 / 4, height / 2, 50);
		large = new Wheel(960 * 3 / 4, height / 2, 100);

	}
	
	void draw() {
		background(255);
		small.rotate(theta);
		small.display();

		large.rotate(theta);
		large.display();

		theta += 0.05;
	}

	class Wheel {
		float r;
		float x;
		float y;
		float theta;

		Wheel(float x_, float y_, float r_) {
			x = x_;
			y = y_;
			r = r_;
		}

		void rotate(float theta_) {
			this.theta = theta_;
		}

		void display() {
			pushMatrix();
				translate(x, y);
				//guideline
				noFill();
				ellipseMode(RADIUS);
				ellipse(0, 0, r, r);
				line(-r, 0, r, 0);
				line(0, -r, 0, r);

				//circular movement
				fill(100);
				ellipse(cos(this.theta) * r, sin(this.theta) * r, 10, 10);

				//vertical movement
				fill(255, 0, 0);
				ellipse(0, sin(this.theta) * r, 10, 10);
				//horizontal movement
				fill(0, 255, 0);
				ellipse(cos(this.theta) * r, 0, 10, 10);

			popMatrix();

		}
	}

	void keyPressed()
	{
		if (key == 's' || key == 'S') {
			saveFrame("myAmplitude####.png");
		}
	}

![](http://i.imgur.com/gcRrHCb.png)

크기와 위치만 다를 뿐 다른 요소가 같은 두 개 이상의 관람차를 표현하기 위해 적당히 클래스를 정의했습니다.

더 큰 관람차를 더 큰 반지름을 가진 원에 비유합시다. 더 먼 거리를 같은 시간에 이동하려면 더 큰 힘이 필요합니다. 마찬가지로 더 큰 진폭을 가진 파장을 만들려면 더 많은 에너지가 필요합니다.

## 에너지 표현하기 ##
파장의 진폭을 보면 얼마나 많은 에너지가 필요한지 상대적으로 알 수 있다고 했습니다. 진폭이 다른 파장을 여러 개 그려보고 정말 그렇게 인식되는지 실험해봅시다.

	//myAmplitudeLines

	PShape lines;
	PShape line;
	float amplitude;
	int nY = 10;
	int nX = 50;

	void setup() {
		size(800, 600);
		background(255);
		smooth();

		lines = createShape(GROUP);
		for (int y = 5; y < height; y += height / nY) {
			amplitude = random(5, 10);

			line = createShape(PShape.PATH);
			line.beginShape();
			for (int x = 5; x < width; x += width / nX) {
				line.vertex(x, y + sin(radians(x)) * sin(radians(x)) * map(y, 0, height, 0, 30));
			}
			line.endShape();

			lines.addChild(line); 
		}

		shape(lines, 0, 0);
	}
	
	void draw() {


	}

	void keyPressed()
	{
		if (key == 's' || key == 'S') {
			saveFrame("myAmplitudeLines####.png");
		}
	}

![](http://i.imgur.com/GfHBEt7.png)

무언가 아쉽습니다. 화면의 아래 위 방향으로는 차이가 느껴지는데 좌우방향으로는 아무런 변화가 없으니 에너지가 많은지 적은지 알기가 힘듭니다. 어떻게 좋은 방법이 없을까요?

## 위상(phase) ##

# 주파수 변조 #
# 변형하기 #
## 개요 ##
loadMainImage() -> createSecondaryImage() ->
### shapeMode() ###
* shapeMode(CORNER): shape(s, upper_left_x, upper_left_y, width, height)
* shapeMode(CORNERS): shape(s, upper_left_x, upper_right_y, lower_right_x, lower_right_y)
* shapeMode(CENTER): shape(s, center_x, center_y, width, height);

### createShape() ###
createShape(GROUP): group of shapes을 정의합니다.

	size(100, 100, P2D)
	//Create the shape group
	alien = createShape(GROUP)
	//Make two shapes
	head = createShape(ELLIPSE, -25, 0, 50, 50)
	head.setFill(color(255))
	body = createShape(RECT, -25, 45, 50, 40)
	body.setFill(color(0))
	//Add the two "child" shapes to the parent group
	alien.addChild(body)
	alien.addChild(head)
	
	background(204)
	translate(50, 15)
	shape(alien)  //Draw the group

### PImage.copy() ###
	
	pimg.copy()
	pimg.copy(sx, sy, sw, sh, dx, dy, dw, dh)
	pimg.copy(src, sx, sy, sw, sh, dx, dy, dw, dh)

		
	pimg	PImage: any object of type PImage
	sx	int: X coordinate of the source's upper left corner
	sy	int: Y coordinate of the source's upper left corner
	sw	int: source image width
	sh	int: source image height
	dx	int: X coordinate of the destination's upper left corner
	dy	int: Y coordinate of the destination's upper left corner
	dw	int: destination image width
	dh	int: destination image height
	src	PImage: an image variable referring to the source image.





