# 내가 만든 앵그리 버드 게임 #
지금까지 우리가 한 작업을 돌이켜봅시다. 우리는 간단한 게임을 만들고 있습니다. 단순히 게임을 만드는 것이 아니라 물리법칙을 적용해보고 이를 위해 OOP를 연습하고 있습니다.

이 중에 가장 재미있었던 것은 물체 간의 충돌을 묘사하는 것입니다. 어떤 물체가 서로 충돌할 때 어떤 일이 일어나는지 간단한 물리법칙을 적용해보았습니다. 예를 들어 `isColliding()`이나 `interactWith()`같은 메세드가 그렇습니다.

하지만 간단한 상호작용을 묘사하는데도 사실 많은 노력을 들여야 했습니다. 우리가 사는 세상의 물체는 원이나 사각형이 아니고 충돌할 때도 더 복잡한 일이 일어납니다. 그 근본에는 `F = MA`라는 간단하기 그지없는 물리법칙이 모든 움직임을 지배하고 있지만 실제로 물체의 움직임을 계산하는 것은 혹은 묘사하는 것은 무척이나 어려운 일입니다.

다른 방법은 없을까요? 이 난관을 극복하는 방법은 우리가 더 복잡하게 움직이는 코드를 작성하는 것 밖에 없는 걸까요? 그럴 리가 없습니다. 

여러분 Box2D라이브러리를 소개합니다.

## Box2D, JBox2D and PBox2D 라이브러리 입문 ##

Box2D라이브러리는 C++로 만들어진 물리엔진 라이브러리입니다. 실제 앵그리버드 게임에 사용된 물리엔진으로도 유명합니다. 이 물리엔진을 자바로 옮긴 것이 JBox2D입니다. PBox2D는 대문자 'P'에서 짐작할 수 있듯 프로세싱이 JBox2D를 이용할 때 편리한 코드를 추가한 라이브러리입니다. 우리는 Box2D를 바로 사용하는 대신 PBox2D를 사용할 것입니다.

### 라이브러리 추가 ###
PBox2D를 사용하려면 라이브러리를 설치해야 합니다. 프로세싱이 제공하는 라이브러리 관리자를 사용해 간단하게 라이브러리를 설치합시다.

프로세싱 메뉴에서 스케치 >> 내부 라이브러리 >> 라이브러리 추가를 선택하세요.

contribution manager 창이 뜨면 box2d 검색어로 검색합니다.

![](http://i.imgur.com/2yLf0ks.png)

위와 같은 화면이 나오면 Box2D for Processing을 선택한 다음 `Install` 버튼을 클릭하세요. 이제 설치가 끝났습니다.

### Box2D 맛보기 ###
본격적인 이야기를 사작하기 전에 우리가 이 라이브러리를 사용해 만들 수 있는 프로그램의 예를 한번 살펴봅시다.

메뉴의 파일 >> 예제 >> contributed library를 선택합니다. 여러 예제 중 BridgeExample을 선택해서 실행합니다.

![](http://i.imgur.com/Hdiri59.png)

클릭할 때마다 박스가 추가되고 박스들의 무게가 늘어남에 따라 다리도 아래로 쳐지는 것을 볼 수 있습니다. 

만약 우리가 이런 프로그램을 처음부터 작성한다면 어떨까요? 꽤 많은 노력이 들어가지 않겠습니까? 하지만 누군가가 이런 라이브러리를 먼저 만들어두었기 때문에 우리는 최소한의 노력으로 우리가 원하는 프로그램을 작성할 수 있습니다.

### Box2D 시작하기: 월드 생성하기  ###
Box2D를 이해하는 쉬운 방법은 여러분을 마치 조물주처럼 보는 것입니다. 새로운 세상(world)에 원하는 물체를 위치하면 그 물체는 여러분이 정한 법칙에 따라 움직입니다. 중력을 세게 할 수도 있고 항상 왼쪽에서 오른쪽으로 바람이 부는 세상을 만들 수도 있습니다. 이제 세상을 창조해 봅시다.

	//myWorld
	import shiffman.box2d.*;
	
	Box2DProcessing box2d;
	
	void setup() {
	    box2d = new Box2DProcessing(this);
		//세상을 창조하고
	    box2d.createWorld();
		//중력은 아래로 향하게 합니다.
	    box2d.setGravity(0, -10);
	}

Box2D는 프로세싱과 다른 좌표체계를 사용합니다. 아래 그램을 보면 알 수 있듯 Box2D는 우리가 수학시간에 다루는 좌표를 사용합니다. 원점이 한 가운데 있기 때문에 바닥으로 작용하는 중력을 나타내려면 `(0, -9.8)`로 힘을 표현해야 합니다.

![](http://i.imgur.com/Es7qzra.png)

같은 중력을 기존 프로세싱코드로 나타내려면 `(0, 10)`으로 표현해야 하겠습니다. 아래와 같은 코드를 본 기억이 있으시지요?

	PVector acceleration = new PVector(0, 10);

### Box2D 시작하기: BodyDef로 Body 정의하기 ###
아무것도 없는 공간은 너무 심심하니 박스를 하나 추가해서 우리가 만든 월드가 어떤 물리법칙을 따르는 지 확인해봅시다.

가장 먼저 해야 할 일은 BodyDef를 선언하는 것입니다. 월드에 body를 추가하려면 먼저 body를 정의해야 합니다.

	...
	//BodyDef Class
	import org.jbox2d.dynamics.*; 
	...
	BodyDef bd;
	
	void setup() {
	    ...
	    bd = new BodyDef();
		...
	}

### Box2D 시작하기: Body 만들기  ###
다음으로 생성한 body의 특성을 추가합시다. 위치는 어디이며 이 물체는 움직이는지 다른 물체와 상호작용하는지 아니면 고정된 채로 움직이지 않는지를 정할 수 있습니다.

Body에는 세가지 종류가 있지만 우선 하나만 살펴봅시다. 월드에 있는 다른 body와 반응하고 이리저리 움직이는 타입을 동적(Dynamic)타입이라고 합니다. 우리가 지금 사용하려고 하는 타입이고 가장 흔하게 사용되는 종류입니다.

`bd`의 위치를 추가합시다.

	//myWorldWithABox - position property

	//Box2DProcessing class
	import shiffman.box2d.*;
	//BodyDef class
	import org.jbox2d.dynamics.*;
	//Vec2 class
	import org.jbox2d.common.*;

	Box2DProcessing box2d;
	BodyDef bd;

	void setup() {
  		size(480, 360);
  		background(255);
  		box2d = new Box2DProcessing(this);
  		box2d.createWorld();
  		box2d.setGravity(0, -10);
  
		//processing의 픽셀단위 좌표를 월드좌표로 convert
  		Vec2 center = box2d.coordPixelsToWorld(width / 2, height / 2);
  		
		bd = new BodyDef();
		bd.type = BodyType.DYNAMIC;
  		bd.position.set(center);
	}

위의 코드를 실행하면 아무 것도 나오지 않습니다. 왜냐하면 아직 Body를 만들지 않았기 때문입니다. 이상한 말일 수도 있는데 Body의 특성을 정의했을 뿐 정작 Body자체는 아직 만들지 않았습니다. 이제 만들어 봅시다.

  	//myWorldWithABox

  	//Box2DProcessing class
  	import shiffman.box2d.*;
  	//BodyDef class
  	import org.jbox2d.dynamics.*;
  	//Vec2 class
  	import org.jbox2d.common.*;

  	Box2DProcessing box2d;
  	BodyDef bd;
  	Body body;

  	void setup() {
      	size(480, 360);
      	background(255);
      	box2d = new Box2DProcessing(this);
      	box2d.createWorld();
      	box2d.setGravity(0, -10);
  
    	//processing의 픽셀단위 좌표를 월드좌표로 convert
     	 Vec2 center = box2d.coordPixelsToWorld(width / 2, height / 2);
      
    	bd = new BodyDef();
    	bd.position.set(center);
    	bd.type = BodyType.DYNAMIC;
		//body를 만듭니다
    	body = box2d.createBody(bd);
    
  	}

### Box2D 시작하기:  Body에 Shape붙이기 ###
하지만 여전히 화면에는 변화가 없습니다. 왜냐하면 화면에 표시하는 작업을 아직 하지 않았기 때문입니다. 이전의 코드에 비유하지면 `move()`를 만들고 매번 위치를 업데이트를 하지만 `display()`를 추가하지 않아 화면에 도형이 나오지 않는 경우라고나 할까요?

Body와 Shape을 분리함으로써 하나의 바디에 여러 쉐이프를 붙일 수 있습니다. 몸은 같으나 다른 모양을 붙일 수 있다는 점은 처음에만 어색할 뿐 나중에는 편리하게 사용할 수 있는 특징입니다.

이제 모양을 만들어 Body에 붙여봅시다. 아래 코드에서 유념할 부분은 scalarPixelsToWorld() 메서드를 이용해 픽셀 단위 너비와 높이를 box2d 단위로 변환했다는 점입니다.

	PolygonShape ps = new PolygonShape();
	float w = 16;
	float h = 16;
	float box2dW = box2d.scalarPixelsToWorld(w / 2);
	float box2dH = box2d.scalarPixelsToWorld(h / 2);
	sd.setAsBox(box2dW, box2dH);

이제 Body에 Shape을 붙여야 합니다. Body와 Shape은 Fixture를 이용해 연결합니다.

### Box2D 시작하기:  Fixture를 이용해 Body와 Shape붙이기 ###
Fixture는 물체의 모양, 밀도, 마찰 그리고 복원력 들을 결정하는 객체입니다. Body가 어떤 Fixture를 가지는지에 따라 해당 Body는 다른 움직임을 보일 것입니다. Fixture의 Shape에 따라서도 다른 궤적을 보입니다. 어떻게 보면 Fixture는 Shape을 포함하는 더 넓은 개념이라고 하겠습니다.

	FixtureDef fd = new FixtureDef();
    //모양
    fd.shape = ps;
	//밀도
    fd.density = 1;
    //마찰
	fd.friction = 0.3;
    //반발력 혹은 복원력
	fd.restitution = 0.5;

	//Fixture와 Body연결하기
	body.createFixture(fd); 

### Box2D 시작하기:  화면에 그리기 ###
이제 마지막 단계입니다. 화면에 우리가 만든 `body`를 그려봅시다. 정리하는 의미로 지금까지 작성한 코드를 모두 확인합시다.

    //myWorldWithABox

    //Box2DProcessing class
    import shiffman.box2d.*;
    //BodyDef, Body, FixtureDef, Fixture classes
    import org.jbox2d.dynamics.*;
    //Vec2 class
    import org.jbox2d.common.*;
    //PolygonShape class
    import org.jbox2d.collision.shapes.*;

    Box2DProcessing box2d;
    BodyDef bd;
    Body body;
    PolygonShape ps;
    FixtureDef fd;
    
    float w;
    float h;
    
    void setup() {
        size(480, 360);
        background(255);
        box2d = new Box2DProcessing(this);
        box2d.createWorld();
        box2d.setGravity(0, -10);

        //processing의 픽셀단위 좌표를 월드좌표로 convert
        Vec2 center = box2d.coordPixelsToWorld(width / 2, height / 2);
        
        bd = new BodyDef();
        bd.position.set(center);
        bd.type = BodyType.DYNAMIC;
        body = box2d.createBody(bd);
        
        ps = new PolygonShape();
        w = 16;
        h = 16;
        float box2dW = box2d.scalarPixelsToWorld(w / 2);
        float box2dH = box2d.scalarPixelsToWorld(h / 2);
        ps.setAsBox(box2dW, box2dH);
 
        fd = new FixtureDef();
        //모양
        fd.shape = ps;
        //밀도
        fd.density = 1;
        //마찰
        fd.friction = 0.3;
        //반발력 혹은 복원력
        fd.restitution = 0.5;

        //Fixture와 Body연결하기
        body.createFixture(fd); 
    }
    
    void draw() {
        background(255);
		//world에서 시간이 경과하면
        box2d.step();
        
        Vec2 position = box2d.getBodyPixelCoord(body);    
        float a = body.getAngle();
        pushMatrix();
        translate(position.x, position.y);
        rotate(-a);
        
        fill(175);
        stroke(0);
        rectMode(CENTER);
        rect(0,0,w,h);
        popMatrix();
    }

![](http://i.imgur.com/odFBTIK.jpg)

`box2d.step()`을 실행하면 World안에서 시간이 흐릅니다. 따로 box의 움직임을 정의하지 않았지만 중력방향으로 박스가 가속하는 것을 관찰할 수 있습니다.

하나만 더 첨언하면 `rotate(-1)`라는 코드가 보입니다. 뜬금없이 마이너스 기호(-)가 나오는 이유는 Box2D와 Processing의 각도 방향이 다르기 때문입니다.

![](http://i.imgur.com/Dspfs8u.png)

### Box2D 시작하기:  바닥 추가하기 ###
지금까지 작성된 코드를 실행하면 박스는 아래로 멈추지 않고 계속 떨어집니다. 이제 World에 바닥을 추가해봅시다.

    //myWorldWithABoxAndFloor

    //Box2DProcessing class
    import shiffman.box2d.*;
    //BodyDef, Body, FixtureDef, Fixture classes
    import org.jbox2d.dynamics.*;
    //Vec2 class
    import org.jbox2d.common.*;
    //PolygonShape class
    import org.jbox2d.collision.shapes.*;

    Box2DProcessing box2d;
    
    BodyDef bd;
    Body body;
    PolygonShape ps;
    FixtureDef fd;
    
    BodyDef bdFloor;
    Body floor;
    PolygonShape psFloor;
    FixtureDef fdFloor;
    
    
    float w;
    float h;
    
    float xFloor;
    float yFloor;
    float wFloor;
    float hFloor;
    
    void setup() {
        size(480, 360);
        background(255);
        box2d = new Box2DProcessing(this);
        box2d.createWorld();
        box2d.setGravity(0, -10);

        //box
        //processing의 픽셀단위 좌표를 월드좌표로 convert
        Vec2 center = box2d.coordPixelsToWorld(width / 2, height / 2);
        
        bd = new BodyDef();
        bd.position.set(center);
        bd.type = BodyType.DYNAMIC;
        body = box2d.createBody(bd);
        
        ps = new PolygonShape();
        w = 16;
        h = 16;
        float box2dW = box2d.scalarPixelsToWorld(w / 2);
        float box2dH = box2d.scalarPixelsToWorld(h / 2);
        ps.setAsBox(box2dW, box2dH);
 
 
        fd = new FixtureDef();
        //모양
        fd.shape = ps;
        //밀도
        fd.density = 1;
        //마찰
        fd.friction = 0.3;
        //반발력 혹은 복원력
        fd.restitution = 0.5;

        //Fixture와 Body연결하기
        body.createFixture(fd);
        
        //floor
        wFloor = width;
        hFloor = 10;
        xFloor = 0;
        yFloor = height - hFloor;

        bdFloor = new BodyDef();
        bdFloor.position.set(box2d.coordPixelsToWorld(xFloor, yFloor));
        bdFloor.type = BodyType.STATIC;
        floor = box2d.createBody(bdFloor);
        
        psFloor = new PolygonShape();
        float box2dFloorW = box2d.scalarPixelsToWorld(wFloor / 2);
        float box2dFloorH = box2d.scalarPixelsToWorld(hFloor / 2);
        psFloor.setAsBox(box2dFloorW, box2dFloorH);
        fdFloor = new FixtureDef();
        fdFloor.shape = psFloor;
        fdFloor.density = 1;
        floor.createFixture(fdFloor);
            
                        
            
    }
    
    void draw() {
        background(255);
        //world에서 시간이 경과하면
        box2d.step();
        
        Vec2 position = box2d.getBodyPixelCoord(body);    
        float a = body.getAngle();
        pushMatrix();
        translate(position.x, position.y);
        rotate(-a);
        
        fill(175);
        stroke(0);
        rectMode(CENTER);
        rect(0,0,w,h);
        popMatrix();
        
        Vec2 floorPosition = box2d.getBodyPixelCoord(floor);
        pushMatrix();
        translate(floorPosition.x, floorPosition.y);
        rect(0, 0, wFloor, hFloor);
        popMatrix();
    }
    
    void keyPressed() {
        if (key == 's' || key == 'S') {
                 saveFrame("myWorldWithABoxAndFloor####.jpg");
        }
    }

![](http://i.imgur.com/fuB7X09.jpg)

바닥과 박스가 상호작용을 합니다. 이전과 다르게 박스가 중력에 의해 아래로 끌려갈 때 회전을 합니다. 따로 규칙을 정하지 않더라도 Box2D world 내부의 body는 그럴듯한 물리법칙을 적용받습니다.

## OOP로 간편하게 만들기 ##
이제 날코딩을 OOP로 묶어볼 시간입니다. Box클래스를 정의해 클릭할 때마다 새 박스가 화면에 추가되게 합시다.

위의 예제를 따라하면서 Box2D와 Processing을 연결하는 법을 맛보았습니다. 이제 이런 경험을 바탕으로 Box 클래스를 정의해 여러 개의 Box 인스턴스를 화면에 뿌려봅시다. 같은 방법으로 Floor도 클래스를 만들어 바닥에 여려 개의 조각을 깔아봅시다.

단계별로 작은 과제를 하나씩 완성해가며 큰 문제를 작은 문제로 쪼개는 법도 잘 봐두세요.

이제부터 전체 코드를 나열하는 대신 관련있는 부분만 확인하기로 합시다. 마지막에 전체 코드를 실겠습니다.

### 필요한 라이브러리 부르기 ###
	
	//myBoxClass: importing necessary classes
	//Box2DProcessing class
	import shiffman.box2d.*;
	//BodyDef, Body, FixtureDef, Fixture classes
	import org.jbox2d.dynamics.*;
	//Vec2 class
	import org.jbox2d.common.*;
	//PolygonShape class
	import org.jbox2d.collision.shapes.*;

### Box 클래스 정의하기 ###

	class Box {

		//Box2D에서 사용할 body
		Body body;
		//픽셀 단위 너비와 높이
		float w;
		float h;

		//Constructor
		//픽셀단위로 위치를 받아 body를 배치함
		//Box2D를 다룰 때 필요한 복잡한 설정을
		//wrapping하고 있음
		Box(float x, float y) {
			//객체가 생성될 때 너비와 높이를 정함
			w = 16;
			h = 16;
			
			//body 정의하기
			////BodyDef 정의하기
			BodyDef bd = new BodyDef();
			bd.type = BodyType.DYNAMIC;
			////(x, y)좌표에 body위치 시키기
    		bd.position.set(box2d.coordPixelsToWorld(x,y));
			////bd정의에 따라 body 인스턴스 생성하기
			body =  box2d.createBody(bd);
			
			////polygon 정의하기
			PolygonShape ps = new PolygonShape();
			float box2dW = box2d.scalarPixelsToWorld(w/2);
    		float box2dH = box2d.scalarPixelsToWorld(h/2);
			//////Box2D는 중심에서 경계까지의 길이를 너비와 높이로 삼습니다
			//////프로세싱의 rectMode(RADIUS)가 Box2D에서는 기본설정입니다
			ps.setAsBox(box2dW, box2dH);

			////fixture정의, 그리고 fixture와 body 연결하기
			FixtureDef fd = new FixtureDef();
    		//////모양
			fd.shape = ps;
    		//////밀도
    		fd.density = 1;
			//////마찰
    		fd.friction = 0.3;
			//////반발력
    		fd.restitution = 0.5;
			//////Fixture와 Body연결하기
        	body.createFixture(fd);
		}

		void display() {
   			//Vec2클래스에 body의 현재위치 저장하기
    		Vec2 pos = box2d.getBodyPixelCoord(body);
			//float a에 body의 회전값 저장하기		
    		float a = body.getAngle();

    		pushMatrix();
    			translate(pos.x,pos.y);
				rotate(-a);
				fill(175);
    			stroke(0);
    			rectMode(CENTER);
    			rect(0,0,w,h);
    		popMatrix();
  		}
	}

### Floor 클래스 정의하기 ###
Floor클래스는 Box클래스와 거의 비슷하지만 body의 타입이 static이라는 점이 Box클래스와 다릅니다.

이런 경우 클래스의 상속을 사용해 차이점만 재정의하면 클래스 전체를 다시 정의하는 수고를 덜 수 있습니다. 하지만 여기서는 전체를 다시 정의하는 방법을 택합니다.

		class Floor {

			//Box2D에서 사용할 body
			Body body;
			//픽셀 단위
			float w;
			float h;
	
			//Constructor
			//픽셀단위로 위치를 받아 body를 배치함
			//Box2D를 다룰 때 필요한 복잡한 설정을
			//wrapping하고 있음
			Floor(float x_, float y_, float w_, floor h_) {
				//객체가 생성될 때 너비와 높이를 정함
				w = w_;
				h = h_;
				 
				//body 정의하기
				////BodyDef 정의하기
				BodyDef bd = new BodyDef();
				//////Body type은 STATIC
				//////고정된 물체입니다
				bd.type = BodyType.STATIC;
				////(x, y)좌표에 body위치 시키기
	    		bd.position.set(box2d.coordPixelsToWorld(x_, y_));
				////bd정의에 따라 body 인스턴스 생성하기
				body =  box2d.createBody(bd);
				
				////polygon 정의하기
				PolygonShape ps = new PolygonShape();
				float box2dW = box2d.scalarPixelsToWorld(w/2);
	    		float box2dH = box2d.scalarPixelsToWorld(h/2);
				//////Box2D는 중심에서 경계까지의 길이를 너비와 높이로 삼습니다
				//////프로세싱의 rectMode(RADIUS)가 Box2D에서는 기본설정입니다
				ps.setAsBox(box2dW, box2dH);
	
				////fixture정의, 그리고 fixture와 body 연결하기
				FixtureDef fd = new FixtureDef();
	    		//////모양
				fd.shape = ps;
	    		//////밀도
	    		fd.density = 1;
				//////마찰
	    		fd.friction = 0.3;
				//////반발력
	    		fd.restitution = 0.5;
				//////Fixture와 Body연결하기
	        	body.createFixture(fd);
			}
	
			void display() {
	   			//Vec2클래스에 body의 현재위치 저장하기
	    		Vec2 pos = box2d.getBodyPixelCoord(body);
				//float a에 body의 회전값 저장하기		
	    		float a = body.getAngle();
	
	    		pushMatrix();
	    			translate(pos.x,pos.y);
					rotate(-a);
					fill(255);
	    			stroke(0);
	    			rectMode(CENTER);
	    			rect(0,0,w,h);
	    		popMatrix();
	  		}
	}

### setup()과 draw()함수 정의하기 ###

	Box2DProcessing box2d;
  	ArrayList<Box> boxes;
 	Floor floor;
  	Floor inAir;

  	void setup() {
	    size(480, 360);
	    background(255);
	    box2d = new Box2DProcessing(this);
	    box2d.createWorld();
	    box2d.setGravity(0, -9.8);
	    boxes = new ArrayList<Box>();
	    floor = new Floor(width / 2, height - 16 / 2, width, 16);
	    inAir = new Floor(width / 2, height / 2 - 16 / 2, width / 2, 16); 
  }

  void draw() {
      background(255);
      box2d.step();

      if(mousePressed) {
          boxes.add(new Box(mouseX, mouseY));
      }
    
      for(Box b: boxes) {
          b.display();
      }
    
      floor.display();
      inAir.display();
    }

![](http://i.imgur.com/2EISxKk.jpg)
		
## Domino ##
## Angry Bird ##







