# 1강 힘과 가속도 관계 이해하기
## 	지난 시간 복습하기 ##
마지막 시간을 떠울려 볼까요? 

객체지향 프로그래밍을 연습하면서 사방으로 튀어다니는 조그만 공을 만들었습니다. 한 번 튀길 때마다 에너지를 조금씩 잃어가는 모습까지도 묘사했습니다. 하지만 방학이 지난 시점에서 여러분이 그런 내용을 기억하고 있을 리가 없지 않겠습니까? 복습하는 뜻으로 다시 한 번 작은 탱탱볼을 그려봅시다.

    //myBall
    class Ball {
            PVector location;
            PVector velocity;
            PVector acceleration;
            
            float radius = 30;
    
            Ball() {
                    location = new PVector(width / 2, height / 2);
                    velocity = new PVector(0, 0);
                    acceleration = new PVector(0, 0.1);
            }
    
            void move() {
                    velocity.add(acceleration);
                    location.add(velocity);
    
                    //오른쪽 벽에 닿이면
                    if (location.x > width - radius) {
                            location.x = width - radius;
                            velocity.x = - velocity.x;
                    }
                    //왼쪽 벽에 닿이면
                    else if (location.x < 0 + radius) {
                            location.x = radius;
                            velocity.x = - velocity.x;
                    }
                    //아래쪽 바닥에 닿이면
                    if (location.y > height - radius) {
                            location.y = height - radius;
                            velocity.y = - 0.9 * velocity.y;
                    }
                    //위쪽 천장에 닿이면
                    else if (location.y < 0 + radius) {
                            location.y = radius;
                            velocity.y = - 0.9 * velocity.y;
                    }
            }
    
            void display() {
                    strokeWeight(5);
                    ellipseMode(RADIUS);
                    ellipse(location.x, location.y, radius, radius);
                    println("acceleration:" + acceleration.x + ", " + acceleration.y);
            }
    }
    
    Ball ball;
    void setup() {
            size(480, 360);
            smooth();
            background(255);
            ball = new Ball();
    }
    
    void draw() {
            background(255);
            ball.move();
            ball.display();
    }

## 퐁 게임 만들기 ##
퐁 게임은 가장 오래된 컴퓨터 게임으로 알려져 있습니다. 컴퓨터가 집채만하고 전기를 먹는 하마일 때에도 한 무리의 사람들은 그런 컴퓨터를 이용해 게임을 만들었고 이런 선구자덕분에 컴퓨터 게임 뿐만 아니라 여타 컴퓨터 분야에 발전이 있었습니다. 이제 프로세싱으로 퐁 게임을 만들어 보며 우리도 컴퓨터 과학 발전에 기여해봅시다.

게임의 승부는 간단하게 결정됩니다. 두 명의 플레이어가 화면 좌우에 있는 패들을 움직이며 자신에게 오는 공이 구멍에 빠지지 않게 합니다.

### 왕복하는 공 ###
화면을 가로지는 공은 우리가 방금 만든 Ball클래스를 활용합시다. 패들 클래스만 추가하고 Ball클래스와 Block클래스가 상호작용할 수 있도록 메서드를 추가합시다.

Block클래스를 만들어 봅시다. 위치와 너비를 정하고 display() 메서드를 추가해 화면에 표시합니다.

	//myPongWithPaddle
	
	class Paddle {
	
		int x;
		int y;
		int w;
		int h;
		
		Paddle(int x_, int y_, int w_, int h_) {
			x = x_;
			y = y_;
			w = w_;
			h = h_;
		}
		
		void display() {
			rect(x, y, w, h);
		}
	}
	
	class Ball {
		PVector location;
		PVector velocity;
		PVector acceleration;
		
		float radius = 15;
	
		Ball() {
			location = new PVector(width / 2, height / 2);
			velocity = new PVector(5, 0);
			acceleration = new PVector(0, 0);
		}
	
		void move() {
			velocity.add(acceleration);
			location.add(velocity);
	
			//오른쪽 벽에 닿이면
			if (location.x > width - radius) {
				location.x = width - radius;
				velocity.x = - velocity.x;
			}
			//왼쪽 벽에 닿이면
			else if (location.x < 0 + radius) {
				location.x = radius;
				velocity.x = - velocity.x;
			}
			//아래쪽 바닥에 닿이면
			if (location.y > height - radius) {
				location.y = height - radius;
				velocity.y = - 0.9 * velocity.y;
			}
			//위쪽 천장에 닿이면
			else if (location.y < 0 + radius) {
				location.y = radius;
				velocity.y = - 0.9 * velocity.y;
			}
		}
	
		void display() {
			strokeWeight(5);
			ellipseMode(RADIUS);
			ellipse(location.x, location.y, radius, radius);
			println("acceleration:" + acceleration.x + ", " + acceleration.y);
		}
		
		
	}
	
	Ball ball;
	Paddle left;
	Paddle right;
	
	void setup() {
		size(480, 360);
		smooth();
		background(255);
		ball = new Ball();
		left = new Paddle(0, 120, 20, 120);
		right = new Paddle(width - 20, 120, 20, 120);
	}
	
	void draw() {
		background(255);
		ball.move();
		ball.display();
		left.display();
		right.display();
	}

### 움직이는 패들 ###
이제 Block클래스를 확장해 키보드를 이용해 위/아래로 움직이게 합니다. 두 개의 block이 서로 다른 키보드 입력에 대해 반응하도록 세심하게 클래스를 정의합시다.

	//myPongWithPaddleMovable
	
	class Paddle {
	
	int x;
	int y;
	int w;
	int h;
	char up;
	char down;
		
	Paddle(int x_, int y_, int w_, int h_, char up_, char down_) {
		x = x_;
		y = y_;
		w = w_;
		h = h_;
		up = up_;
		down = down_;
	}
	
	void update(char key) {
		if (key == up) {
		y -= 10;
		y = constrain(y, 0, height);
		}
		else if (key == down) {
		y += 10;
		y = constrain(y, 0, height - h);
		}
	}
	
	void display() {
		rect(x, y, w, h);
	}
	}
	
	class Ball {
		PVector location;
		PVector velocity;
		PVector acceleration;
		
		float radius = 15;
	
		Ball() {
			location = new PVector(width / 2, height / 2);
			velocity = new PVector(5, 0);
			acceleration = new PVector(0, 0);
		}
	
		void move() {
			velocity.add(acceleration);
			location.add(velocity);
	
			//오른쪽 벽에 닿이면
			if (location.x > width - radius) {
				location.x = width - radius;
				velocity.x = - velocity.x;
			}
			//왼쪽 벽에 닿이면
			else if (location.x < 0 + radius) {
				location.x = radius;
				velocity.x = - velocity.x;
			}
			//아래쪽 바닥에 닿이면
			if (location.y > height - radius) {
				location.y = height - radius;
				velocity.y = - 0.9 * velocity.y;
			}
			//위쪽 천장에 닿이면
			else if (location.y < 0 + radius) {
				location.y = radius;
				velocity.y = - 0.9 * velocity.y;
			}
		}
	
		void display() {
			strokeWeight(5);
			ellipseMode(RADIUS);
			ellipse(location.x, location.y, radius, radius);
			println("acceleration:" + acceleration.x + ", " + acceleration.y);
		}
		
		
	}
	
	Ball ball;
	Paddle left;
	Paddle right;
	
	void setup() {
		size(480, 360);
		smooth();
		background(255);
		ball = new Ball();
		left = new Paddle(10, 120, 20, 120, 'q', 'a');
		right = new Paddle(width - 10 - 20, 120, 20, 120, 'p', 'l');
	}
	
	void draw() {
		background(255);
		ball.move();
		ball.display();
		left.display();
		right.display();
	}
	
	void keyPressed() {
		left.update(key);
		right.update(key);
	}

### 공과 패들의 상호작용 ###
공이 화면을 왕복하고 있지만 패들과 상호작용하면서 움직이는 것은 아닙니다. 이제 공과 패들이 만나는 경우에만 반대로 반사되도록 코드를 수정합시다.

상호작용을 정의하는 것도 작은 단계로 나눠 하나씩 해나갑시다. 맨 처음 해야 할 일은 
공과 패들이 닿이면 색이 바뀌도록 하는 일입니다.

	//myPongWithPaddleMovableInteractive
	
	class Paddle {
		
		int x;
		int y;
		int w;
		int h;
		char up;
		char down;
				
		Paddle(int x_, int y_, int w_, int h_, char up_, char down_) {
			x = x_;
			y = y_;
			w = w_;
			h = h_;
			up = up_;
			down = down_;
		}
		
		void update(char key) {
			if (key == up) {
				y -= 10;
				y = constrain(y, 0, height);
			}
			else if (key == down) {
				y += 10;
				y = constrain(y, 0, height - h);
			}
		}
		
		void display() {
			rect(x, y, w, h);
		}
	}
	
	class Ball {
			PVector location;
			PVector velocity;
			PVector acceleration;
			
			float radius = 15;
	
			Ball() {
					location = new PVector(width / 2, height / 2);
					velocity = new PVector(5, 0);
					acceleration = new PVector(0, 0);
			}
	
			void move() {
					velocity.add(acceleration);
					location.add(velocity);
	
					//오른쪽 벽에 닿이면
					if (location.x > width - radius) {
							location.x = width - radius;
							velocity.x = - velocity.x;
					}
					//왼쪽 벽에 닿이면
					else if (location.x < 0 + radius) {
							location.x = radius;
							velocity.x = - velocity.x;
					}
					//아래쪽 바닥에 닿이면
					if (location.y > height - radius) {
							location.y = height - radius;
							velocity.y = - 0.9 * velocity.y;
					}
					//위쪽 천장에 닿이면
					else if (location.y < 0 + radius) {
							location.y = radius;
							velocity.y = - 0.9 * velocity.y;
					}
			}
	
			void display() {
					strokeWeight(5);
					ellipseMode(RADIUS);
					ellipse(location.x, location.y, radius, radius);
					println("acceleration:" + acceleration.x + ", " + acceleration.y);
			}
			
			boolean isColliding(Block b) {
						//borders
						float left = b.x - radius;
						float right = b.x + b.w + radius;
						float top = b.y - radius;
						float bottom = b.y  + b.h + radius;
						if ((location.x > left) && (location.x < right) && (location.y > top) && (location.y < bottom)){
							return true;
						}
						else {
							return false;
						}
			}
			
			
	}
	
	Ball ball;
	Paddle left;
	Paddle right;
	
	void setup() {
			size(480, 360);
			smooth();
			background(255);
			ball = new Ball();
			left = new Paddle(10, 120, 20, 120, 'q', 'a');
			right = new Paddle(width - 10 - 20, 120, 20, 120, 'p', 'l');
	}
	
	void draw() {
			background(255);
			noFill();
			ball.move();
			if (ball.isColliding(left)) {
				fill(100);
				left.display();
				ball.display();
				noFill();
				right.display();
			}
			else if (ball.isColliding(right)) {
				fill(100);
				right.display();
				ball.display();
				noFill();
				left.display();
			}
			else {
				left.display();
				right.display();
				ball.display();
			}
		 
	}
	
	void keyPressed() {
		left.update(key);
		right.update(key);
	}

이제 패들에 공이 튕기도록 수정합시다. Ball 클래스와 Paddle클래스 두가지 모두 수정이 필요합니다. 어떤 부분이 바뀌는지 유심히 지켜봅시다.

	//myPongWithPaddleMovableInteractiveBouncing
	class Paddle {
		
		int x;
		int y;
		int w;
		int h;
		char up;
		char down;
				
		Paddle(int x_, int y_, int w_, int h_, char up_, char down_) {
			x = x_;
			y = y_;
			w = w_;
			h = h_;
			up = up_;
			down = down_;
		}
		
		//키보드를 누르면 위/아래로 움직입니다
		void update(char key) {
			if (key == up) {
				y -= 10;
				y = constrain(y, 0, height);
			}
			else if (key == down) {
				y += 10;
				y = constrain(y, 0, height - h);
			}
		}
		
		void display() {
			rect(x, y, w, h);
		}
	}
		
	class Ball {
		PVector location;
		PVector velocity;
		PVector acceleration;
			
		float radius = 15;
	
		Ball() {
			location = new PVector(width / 2, height / 2);
			velocity = new PVector(random(1) > 0.5 ? 5 : -5, 0);
			acceleration = new PVector(0, 0);
		}
			
		//공의 속도와 위치를 업데이트 합니다
		void move() {
			velocity.add(acceleration);
			location.add(velocity);
					
					
			//오른쪽 벽에 닿이면
			if (location.x > width - radius) {
				println("Ball reache sreached right border.");
				println("Player one won the game!.");
				location = new PVector(width / 2, height / 2);
				//임의의 방향으로 새 게임을 시작합니다
				velocity = new PVector(random(1) > 0.5 ? 5 : -5, 0);
			}
			//왼쪽 벽에 닿이면
			else if (location.x < 0 + radius) {
				println("Ball reache sreached right border.");
				println("Player two won the game!.");
				location = new PVector(width / 2, height / 2);
				//임의의 방향으로 새 게임을 시작합니다
				velocity = new PVector(random(1) > 0.5 ? 5 : -5, 0);
			}
			//아래쪽 바닥에 닿이면
			else if (location.y > height - radius) {
				location.y = height - radius;
				velocity.y = - 1 * velocity.y;
			}
			//위쪽 천장에 닿이면
			else if (location.y < 0 + radius) {
				location.y = radius;
				velocity.y = - 1 * velocity.y;
			}
		}
			
		//paddle과 상호작용합니다
		void interactWith(Paddle p) {
			if (isColliding(p)) {
				velocity.x *= -1;
			}
		}
	
		void display() {
			strokeWeight(5);
			ellipseMode(RADIUS);
			ellipse(location.x, location.y, radius, radius);
		}
			
		//공과 패들이 충돌하는지를 알려줍니다
		boolean isColliding(Paddle b) {
			//borders
			float left = b.x - radius;
			float right = b.x + b.w + radius;
			float top = b.y - radius;
			float bottom = b.y  + b.h + radius;
			if ((location.x > left) && (location.x < right) && (location.y > top) && (location.y < bottom)){
				return true;
			}
			else {
				return false;
			}
		}
	}
		
	Ball ball;
	Paddle left;
	Paddle right;
	
	void setup() {
		size(480, 360);
		smooth();
		background(255);
		ball = new Ball();
		left = new Paddle(10, 120, 20, 120, 'q', 'a');
		right = new Paddle(width - 10 - 20, 120, 20, 120, 'p', 'l');
	}
	
	void draw() {
		background(255);
		noFill();
		ball.interactWith(left);
		ball.interactWith(right);
		ball.move();
			
		if (ball.isColliding(left)) {
			fill(100);
			left.display();
			ball.display();
			noFill();
			right.display();
		}
		else if (ball.isColliding(right)) {
			fill(100);
			right.display();
			ball.display();
			noFill();
			left.display();
		}
		else {
			left.display();
			right.display();
			ball.display();
		}
	}
	
	void keyPressed() {
		left.update(key);
		right.update(key);
	}

### 공과 패들의 상호작용: 비스듬하게 패들에 부딪히는 공 ###
지금까지 공은 가로축을 따라 좌우로 움직였습니다. 코드를 약간 손봐서 여러 각도로 움직이도록 합시다. 어떤 부분을 바꾸었는지 잘 살펴보세요. 생각보다 수정된 부분이 얼마되지 않습니다.

	//myPongWithPaddleMovableInteractiveBouncingVariableAngle
        
    class Paddle {
        
        int x;
        int y;
        int w;
        int h;
        char up;
        char down;
                
        Paddle(int x_, int y_, int w_, int h_, char up_, char down_) {
            x = x_;
            y = y_;
            w = w_;
            h = h_;
            up = up_;
            down = down_;
        }
        
        //키보드를 누르면 위/아래로 움직입니다
        void update(char key) {
            if (key == up) {
                y -= 10;
                y = constrain(y, 0, height);
            }
            else if (key == down) {
                y += 10;
                y = constrain(y, 0, height - h);
            }
        }
        
        void display() {
            rect(x, y, w, h);
        }
    }
        
    class Ball {
        PVector location;
        PVector velocity;
        PVector acceleration;
        
        float radius = 15;
    
        Ball() {
            location = new PVector(width / 2, height / 2);
			//PVector.randim2D()를 사용합니다
            velocity = PVector.random2D().mult(5);
            acceleration = new PVector(0, 0);
        }
        
        //공의 속도와 위치를 업데이트 합니다
        void move() {
            velocity.add(acceleration);
            location.add(velocity);
                
                
            //오른쪽 벽에 닿이면
            if (location.x > width - radius) {
                println("Ball reache sreached right border.");
                println("Player one won the game!.");
                location = new PVector(width / 2, height / 2);
                //임의의 방향으로 새 게임을 시작합니다
				//PVector.randim2D()를 사용합니다
                velocity = PVector.random2D().mult(5);
            }
            //왼쪽 벽에 닿이면
            else if (location.x < 0 + radius) {
                println("Ball reache sreached right border.");
                println("Player two won the game!.");
                location = new PVector(width / 2, height / 2);
                //임의의 방향으로 새 게임을 시작합니다
				//PVector.randim2D()를 사용합니다
                velocity = PVector.random2D().mult(5);
            }
            //아래쪽 바닥에 닿이면
            if (location.y > height - radius) {
                location.y = height - radius;
                velocity.y = - 1 * velocity.y;
            }
            //위쪽 천장에 닿이면
            else if (location.y < 0 + radius) {
                location.y = radius;
                velocity.y = - 1 * velocity.y;
            }
        }
        
        //paddle과 상호작용합니다
        void interactWith(Paddle p) {
            if (isColliding(p)) {
                velocity.x *= -1.0;
                velocity.mult(1.03);
            }
        }

        void display() {
            strokeWeight(5);
            ellipseMode(RADIUS);
            ellipse(location.x, location.y, radius, radius);
        }
        
        //공과 패들이 충돌하는지를 알려줍니다
        boolean isColliding(Paddle b) {
            //borders
            float left = b.x - radius;
            float right = b.x + b.w + radius;
            float top = b.y - radius;
            float bottom = b.y  + b.h + radius;
            if ((location.x > left) && (location.x < right) && (location.y > top) && (location.y < bottom)){
                return true;
            }
            else {
                return false;
            }
        }
    }
        
    Ball ball;
    Paddle left;
    Paddle right;
    
    void setup() {
        size(480, 360);
        smooth();
        background(255);
        ball = new Ball();
        left = new Paddle(10, 120, 20, 120, 'q', 'a');
        right = new Paddle(width - 10 - 20, 120, 20, 120, 'p', 'l');
    }
    
    void draw() {
        background(255);
        noFill();
        ball.interactWith(left);
        ball.interactWith(right);
        ball.move();
        
        if (ball.isColliding(left)) {
            fill(100);
            left.display();
            ball.display();
            noFill();
            right.display();
        }
        else if (ball.isColliding(right)) {
            fill(100);
            right.display();
            ball.display();
            noFill();
            left.display();
        }
        else {
            left.display();
            right.display();
            ball.display();
        }
    }
    
    void keyPressed() {
        left.update(key);
        right.update(key);
    }

