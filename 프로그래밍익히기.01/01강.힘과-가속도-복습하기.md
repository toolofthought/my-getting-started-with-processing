# 1강 힘과 가속도 관계 이해하기
## 	지난 시간 복습하기 ##
마지막 시간을 떠울려 볼까요? 

객체지향 프로그래밍을 연습하면서 사방으로 튀어다니는 조그만 공을 만들었습니다. 한 번 튀길 때마다 에너지를 조금씩 잃어가는 모습까지도 묘사했습니다. 하지만 방학이 지난 시점에서 여러분이 그런 내용을 기억하고 있을 리가 없지 않겠습니까? 복습하는 뜻으로 다시 한 번 작은 탱탱볼을 그려봅시다.

    //myBall
    class Ball {
            PVector location;
            PVector velocity;
            PVector acceleration;
            
            float radius = 30;
    
            Ball() {
                    location = new PVector(width / 2, height / 2);
                    velocity = new PVector(0, 0);
                    acceleration = new PVector(0, 0.1);
            }
    
            void move() {
                    velocity.add(acceleration);
                    location.add(velocity);
    
                    //오른쪽 벽에 닿이면
                    if (location.x > width - radius) {
                            location.x = width - radius;
                            velocity.x = - velocity.x;
                    }
                    //왼쪽 벽에 닿이면
                    else if (location.x < 0 + radius) {
                            location.x = radius;
                            velocity.x = - velocity.x;
                    }
                    //아래쪽 바닥에 닿이면
                    if (location.y > height - radius) {
                            location.y = height - radius;
                            velocity.y = - 0.9 * velocity.y;
                    }
                    //위쪽 천장에 닿이면
                    else if (location.y < 0 + radius) {
                            location.y = radius;
                            velocity.y = - 0.9 * velocity.y;
                    }
            }
    
            void display() {
                    strokeWeight(5);
                    ellipseMode(RADIUS);
                    ellipse(location.x, location.y, radius, radius);
                    println("acceleration:" + acceleration.x + ", " + acceleration.y);
            }
    }
    
    Ball ball;
    void setup() {
            size(480, 360);
            smooth();
            background(255);
            ball = new Ball();
    }
    
    void draw() {
            background(255);
            ball.move();
            ball.display();
    }

## 퐁 게임 만들기 ##
퐁 게임은 가장 오래된 컴퓨터 게임으로 알려져 있습니다. 컴퓨터가 집채만하고 전기를 먹는 하마일 때에도 한 무리의 사람들은 그런 컴퓨터를 이용해 게임을 만들었고 이런 선구자덕분에 컴퓨터 게임 뿐만 아니라 여타 컴퓨터 분야에 발전이 있었습니다. 이제 프로세싱으로 퐁 게임을 만들어 보며 우리도 컴퓨터 과학 발전에 기여해봅시다.

게임의 승부는 간단하게 결정됩니다. 두 명의 플레이어가 화면 좌우에 있는 블록을 움직이며 자신에게 오는 공이 구멍에 빠지지 않게 합니다.

### 왕복하는 공 ###
화면을 가로지는 공은 우리가 방금 만든 Ball클래스를 활용합시다. 블록 클래스만 추가하고 Ball클래스와 Block클래스가 상호작용할 수 있도록 메서드를 추가합시다.

Block클래스를 만들어 봅시다. 위치와 너비를 정하고 display() 메서드를 추가해 화면에 표시합니다.

	//myPongWithPaddle
	
	class Paddle {
	
		int x;
		int y;
		int w;
		int h;
		
		Paddle(int x_, int y_, int w_, int h_) {
			x = x_;
			y = y_;
			w = w_;
			h = h_;
		}
		
		void display() {
			rect(x, y, w, h);
		}
	}
	
	class Ball {
		PVector location;
		PVector velocity;
		PVector acceleration;
		
		float radius = 15;
	
		Ball() {
			location = new PVector(width / 2, height / 2);
			velocity = new PVector(5, 0);
			acceleration = new PVector(0, 0);
		}
	
		void move() {
			velocity.add(acceleration);
			location.add(velocity);
	
			//오른쪽 벽에 닿이면
			if (location.x > width - radius) {
				location.x = width - radius;
				velocity.x = - velocity.x;
			}
			//왼쪽 벽에 닿이면
			else if (location.x < 0 + radius) {
				location.x = radius;
				velocity.x = - velocity.x;
			}
			//아래쪽 바닥에 닿이면
			if (location.y > height - radius) {
				location.y = height - radius;
				velocity.y = - 0.9 * velocity.y;
			}
			//위쪽 천장에 닿이면
			else if (location.y < 0 + radius) {
				location.y = radius;
				velocity.y = - 0.9 * velocity.y;
			}
		}
	
		void display() {
			strokeWeight(5);
			ellipseMode(RADIUS);
			ellipse(location.x, location.y, radius, radius);
			println("acceleration:" + acceleration.x + ", " + acceleration.y);
		}
		
		
	}
	
	Ball ball;
	Paddle left;
	Paddle right;
	
	void setup() {
		size(480, 360);
		smooth();
		background(255);
		ball = new Ball();
		left = new Paddle(0, 120, 20, 120);
		right = new Paddle(width - 20, 120, 20, 120);
	}
	
	void draw() {
		background(255);
		ball.move();
		ball.display();
		left.display();
		right.display();
	}

### 움직이는 블록 ###
이제 Block클래스를 확장해 키보드를 이용해 위/아래로 움직이게 합니다. 두 개의 block이 서로 다른 키보드 입력에 대해 반응하도록 세심하게 클래스를 정의합시다.

	//myPongWithPaddleMovable
	
	class Paddle {
	
	int x;
	int y;
	int w;
	int h;
	char up;
	char down;
		
	Paddle(int x_, int y_, int w_, int h_, char up_, char down_) {
		x = x_;
		y = y_;
		w = w_;
		h = h_;
		up = up_;
		down = down_;
	}
	
	void update(char key) {
		if (key == up) {
		y -= 10;
		y = constrain(y, 0, height);
		}
		else if (key == down) {
		y += 10;
		y = constrain(y, 0, height - h);
		}
	}
	
	void display() {
		rect(x, y, w, h);
	}
	}
	
	class Ball {
		PVector location;
		PVector velocity;
		PVector acceleration;
		
		float radius = 15;
	
		Ball() {
			location = new PVector(width / 2, height / 2);
			velocity = new PVector(5, 0);
			acceleration = new PVector(0, 0);
		}
	
		void move() {
			velocity.add(acceleration);
			location.add(velocity);
	
			//오른쪽 벽에 닿이면
			if (location.x > width - radius) {
				location.x = width - radius;
				velocity.x = - velocity.x;
			}
			//왼쪽 벽에 닿이면
			else if (location.x < 0 + radius) {
				location.x = radius;
				velocity.x = - velocity.x;
			}
			//아래쪽 바닥에 닿이면
			if (location.y > height - radius) {
				location.y = height - radius;
				velocity.y = - 0.9 * velocity.y;
			}
			//위쪽 천장에 닿이면
			else if (location.y < 0 + radius) {
				location.y = radius;
				velocity.y = - 0.9 * velocity.y;
			}
		}
	
		void display() {
			strokeWeight(5);
			ellipseMode(RADIUS);
			ellipse(location.x, location.y, radius, radius);
			println("acceleration:" + acceleration.x + ", " + acceleration.y);
		}
		
		
	}
	
	Ball ball;
	Paddle left;
	Paddle right;
	
	void setup() {
		size(480, 360);
		smooth();
		background(255);
		ball = new Ball();
		left = new Paddle(10, 120, 20, 120, 'q', 'a');
		right = new Paddle(width - 10 - 20, 120, 20, 120, 'p', 'l');
	}
	
	void draw() {
		background(255);
		ball.move();
		ball.display();
		left.display();
		right.display();
	}
	
	void keyPressed() {
		left.update(key);
		right.update(key);
	}

### 공과 블록의 상호작용 ###
공이 화면을 왕복하고 있지만 블록과 상호작용하면서 움직이는 것은 아닙니다. 이제 공과 블록이 만나는 경우에만 반대로 반사되도록 코드를 수정합시다.

상호작용을 정의하는 것도 작은 단계로 나눠 하나씩 해나갑시다. 맨 처음 해야 할 일은 
공과 블록이 닿이면 색이 바뀌도록 하는 일입니다.

	//myPongWithPaddleMovableInteractive
	
	class Paddle {
		
		int x;
		int y;
		int w;
		int h;
		char up;
		char down;
				
		Paddle(int x_, int y_, int w_, int h_, char up_, char down_) {
			x = x_;
			y = y_;
			w = w_;
			h = h_;
			up = up_;
			down = down_;
		}
		
		void update(char key) {
			if (key == up) {
				y -= 10;
				y = constrain(y, 0, height);
			}
			else if (key == down) {
				y += 10;
				y = constrain(y, 0, height - h);
			}
		}
		
		void display() {
			rect(x, y, w, h);
		}
	}
	
	class Ball {
			PVector location;
			PVector velocity;
			PVector acceleration;
			
			float radius = 15;
	
			Ball() {
					location = new PVector(width / 2, height / 2);
					velocity = new PVector(5, 0);
					acceleration = new PVector(0, 0);
			}
	
			void move() {
					velocity.add(acceleration);
					location.add(velocity);
	
					//오른쪽 벽에 닿이면
					if (location.x > width - radius) {
							location.x = width - radius;
							velocity.x = - velocity.x;
					}
					//왼쪽 벽에 닿이면
					else if (location.x < 0 + radius) {
							location.x = radius;
							velocity.x = - velocity.x;
					}
					//아래쪽 바닥에 닿이면
					if (location.y > height - radius) {
							location.y = height - radius;
							velocity.y = - 0.9 * velocity.y;
					}
					//위쪽 천장에 닿이면
					else if (location.y < 0 + radius) {
							location.y = radius;
							velocity.y = - 0.9 * velocity.y;
					}
			}
	
			void display() {
					strokeWeight(5);
					ellipseMode(RADIUS);
					ellipse(location.x, location.y, radius, radius);
					println("acceleration:" + acceleration.x + ", " + acceleration.y);
			}
			
			boolean isColliding(Block b) {
						//borders
						float left = b.x - radius;
						float right = b.x + b.w + radius;
						float top = b.y - radius;
						float bottom = b.y  + b.h + radius;
						if ((location.x > left) && (location.x < right) && (location.y > top) && (location.y < bottom)){
							return true;
						}
						else {
							return false;
						}
			}
			
			
	}
	
	Ball ball;
	Paddle left;
	Paddle right;
	
	void setup() {
			size(480, 360);
			smooth();
			background(255);
			ball = new Ball();
			left = new Paddle(10, 120, 20, 120, 'q', 'a');
			right = new Paddle(width - 10 - 20, 120, 20, 120, 'p', 'l');
	}
	
	void draw() {
			background(255);
			noFill();
			ball.move();
			if (ball.isColliding(left)) {
				fill(100);
				left.display();
				ball.display();
				noFill();
				right.display();
			}
			else if (ball.isColliding(right)) {
				fill(100);
				right.display();
				ball.display();
				noFill();
				left.display();
			}
			else {
				left.display();
				right.display();
				ball.display();
			}
		 
	}
	
	void keyPressed() {
		left.update(key);
		right.update(key);
	}

## 피사의 사탑 실험 ##
피사의 사탑은 이탈리아에 위치한 건축물입니다.
 
![](http://i.imgur.com/lH3JpRB.jpg)

전세계 관광객들이 이곳에서 아래 사진처럼 우스꽝스러운 모습을 연출하는 것으로 유명합니다.

![](http://i.imgur.com/0tWtqPH.jpg)
![](http://i.imgur.com/2Vw2oNf.jpg)

바보같아보여도 좋으니 한 번 가보고 싶은 생각이 듭니다. 어쨌든 이 곳이 명성을 얻게 된 이유는 갈릴레이의 실험과 관련이 있습니다. 갈릴레이가 이곳에서 발코니의 난간에서 무게가 다른 두 개의 공을 동시에 떨어뜨렸다는 이야기가 지금까지 전해지면서 피사의 사탑이 유명해졌다고 합니다.

무게가 다른 두 개의 공은 어떻게 되었을까요? 동시에 바닥에 떨어졌을까요? 아니면 무거운 공이 먼저 떨어졌을까요? 아니면 반대로 가벼운 공이?

갈릴레이는 피사의 사탑에서 실험했지만 우리는 프로세싱으로 간단하게 실험해보겠습니다.

### 만유인력 ###
공은 대체 왜 지구로 떨어지는 것일까요? 우리는 힘이 있는 곳에 가속도가 있고 가속도가 있는 곳에 힘이 존재함을 알고 있습니다. 물체를 공중에 가만히 두면 바닥으로 가속운동을 합니다. 그 말인즉슨 바닥이 물체에 힘을 가하고 있다는 말과 같은 말이 됩니다.

다시 한 번 확인해볼까요? '가속 = 힘'. 힘이 있으면 가속이 있고 가속이 있으면 힘이 있다. 얼마만큼의 힘이 작용할까요? 일찌기 뉴튼은 아래와 같은 관계를 발견했습니다.

![](http://i.imgur.com/8s1yAhu.jpg)

두 개의 물체는 서로를 잡아당기는데 그 힘은 두 물체의 무게의 곱에 비례하고 거리의 제곱에 반비례한다는 뜻입니다. 지구의 무게는 동일하고 가벼운 공과 무거운 공과 지구와의 거리도 같습니다. 공의 무게 정도가 상이할 뿐 차이가 있는 다른 부분을 찾을 수 없습니다. 이제 acceleration을 임의의 상수로 입력하는 대신 위의 식을 활용해 매 순간 공에 작용하는 중력을 계산해봅시다.













퐁 게임 만들기

 

