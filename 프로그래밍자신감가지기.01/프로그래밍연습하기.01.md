# 3D 공간에 도형 그리기 #
## 격자 그리기 ##
### 기본 격자 ###
	//myGrid
	int nX = 20;
	int nY = 15;
	
	void setup() {
		size(480, 360, P3D);
		strokeWeight(1 / 40.0);
	}
	
	void draw() {
		background(255);
		translate(50, 50);
		scale(20);
		for (int y = 0; y < nY; y++) {
			beginShape(QUAD_STRIP);
			for (int x = 0; x <= nX; x++) {
				vertex(x, y, 0);
				vertex(x, y + 1, 0);
			}
			endShape();
		}
	}

![](http://i.imgur.com/EMgqbEC.jpg)

### 시점 변경하기 ##

	//myGridSetView
	int nX = 20;
	int nY = 15;
	float rotationX;
	float rotationY;
	float targetRotationX;
	float targetRotationY;
	float clickRotationX;
	float clickRotationY;
	float offsetX;
	float offsetY;
	float clickMouseX;
	float clickMouseY;
	
	void setup() {
		size(480, 360, P3D);
		strokeWeight(1 / 40.0);
	}
	
	void draw() {
		background(255);
		translate(50, 50);
		setView();
		scale(20);
		for (int y = 0; y < nY; y++) {
			beginShape(QUAD_STRIP);
			for (int x = 0; x <= nX; x++) {
				vertex(x, y, 0);
				vertex(x, y + 1, 0);
			}
			endShape();
		}
	}

	void setView() {
		if (mousePressed) {
			offsetX = mouseX - clickMouseX;
			offsetY = mouseY - clickMouseY;
			targetRotationX = clickRotationX + offsetX / width * TWO_PI;
			targetRotationY = clickRotationY + offsetY / height * TWO_PI;
			rotationX += (targetRotationX - rotationX) * 0.25;
			rotationY += (targetRotationY - rotationY) * 0.25;
		}
		rotateX(-rotationY);
		rotateY(rotationX);
	}

	void mousePressed() {
		clickRotationX = rotationX;
		clickRotationY = rotationY;
		clickMouseX = mouseX;
		clickMouseY = mouseY;
	}

![](http://i.imgur.com/E4UXiiv.jpg)
### sin(x) ###
	//myGridSine

	int nX = 20;
	int nY = 15;
	float rotationX;
	float rotationY;
	float clickRotationX;
	float clickRotationY;
	float targetRotationX;
	float targetRotationY;
	float offsetX;
	float offsetY;
	float clickMouseX;
	float clickMouseY;

	void setup() {
		size(480, 360, P3D);
		strokeWeight(1/40.0);
	}

	void draw() {
		background(255);
		translate(50, 50);
		setView();
		scale(20);
		for (int y = 0; y < nY; y++) {
			beginShape(QUAD_STRIP);
			for (int x = 0; x <= nX; x++) {
				vertex(x, y, sin(x));
				vertex(x, y + 1, sin(x));
			}
			endShape();
		}
	}

	void mousePressed() {
		clickMouseX = mouseX;
		clickMouseY = mouseY;
		clickRotationX = rotationX;
		clickRotationY = rotationY;
	}

	void setView() {
		if (mousePressed) {
			offsetX = mouseX - clickMouseX;
			offsetY = mouseY - clickMouseY;
			targetRotationX = clickRotationX + offsetX / width * TWO_PI;
			targetRotationY = clickRotationY + offsetY / height * TWO_PI;
			rotationX += (targetRotationX - rotationX) * 0.1;
			rotationY += (targetRotationY - rotationY) * 0.1;
		}
		rotateX(-rotationY);
		rotateY(rotationX);
	}
	
![](http://i.imgur.com/hmRX1eZ.jpg)

### sin(sqrt(x*x + y*y)) ###
	//myGridSineSqrt

	int nX = 20;
	int nY = 15;
	float rotationX;
	float rotationY;
	float clickRotationX;
	float clickRotationY;
	float targetRotationX;
	float targetRotationY;
	float offsetX;
	float offsetY;
	float clickMouseX;
	float clickMouseY;

	void setup() {
		size(480, 360, P3D);
		strokeWeight(1/40.0);
	}

	void draw() {
		background(255);
		translate(50, 50);
		setView();
		scale(20);
		for (int y = 0; y < nY; y++) {
			beginShape(QUAD_STRIP);
			for (int x = 0; x <= nX; x++) {
				vertex(x, y, sin(sqrt(x*x + y*y)));
				vertex(x, y + 1, sin(sqrt(x*x + (y+1)*(y+1))));
			}
			endShape();
		}
	}

	void mousePressed() {
		clickMouseX = mouseX;
		clickMouseY = mouseY;
		clickRotationX = rotationX;
		clickRotationY = rotationY;
	}

	void setView() {
		if (mousePressed) {
			offsetX = mouseX - clickMouseX;
			offsetY = mouseY - clickMouseY;
			targetRotationX = clickRotationX + offsetX / width * TWO_PI;
			targetRotationY = clickRotationY + offsetY / height * TWO_PI;
			rotationX += (targetRotationX - rotationX) * 0.1;
			rotationY += (targetRotationY - rotationY) * 0.1;
		}
		rotateX(-rotationY);
		rotateY(rotationX);
	}

![](http://i.imgur.com/eirMj8X.jpg)
### cos(sqrt(x*x + y * y)) ###
	
	//myGridCosineSqrt

	int nU = 20;
	int nMax = 10;
	int nMin = -10;

	int nV = 15;
	int nMax = 10;
	int nMin = -10;
	
	float rotationX;
	float rotationY;
	float clickRotationX;
	float clickRotationY;
	float targetRotationX;
	float targetRotationY;
	float offsetX;
	float offsetY;
	float clickMouseX;
	float clickMouseY;

	void setup() {
		size(480, 360, P3D);
		strokeWeight(1/40.0);
	}

	void draw() {
		background(255);
		translate(50, 50);
		setView();
		scale(20);
		for (int i = 0; i < nU; i++) {
			beginShape(QUAD_STRIP);
			for (int j = 0; j <= nV; j++) {
				float u = map(j, 0, nU, minU, maxU);
				float v = map(i, 0, nV, minV, maxV);
				float x = v;
				float y = u;
				float z = cos(sqrt(v*v + u*u));
				vertex(x, y, z);
				
				
				
			}
			endShape();
		}
	}

	void mousePressed() {
		clickMouseX = mouseX;
		clickMouseY = mouseY;
		clickRotationX = rotationX;
		clickRotationY = rotationY;
	}

	void setView() {
		if (mousePressed) {
			offsetX = mouseX - clickMouseX;
			offsetY = mouseY - clickMouseY;
			targetRotationX = clickRotationX + offsetX / width * TWO_PI;
			targetRotationY = clickRotationY + offsetY / height * TWO_PI;
			rotationX += (targetRotationX - rotationX) * 0.1;
			rotationY += (targetRotationY - rotationY) * 0.1;
		}
		rotateX(-rotationY);
		rotateY(rotationX);
	}
### (0.75u, sin(u) * v, cos(u) * sin(v) ###
### half-open sphere ###

// array for the grid points
// initialize array
PVector[][] points = new PVector[vCount+1][uCount+1];

// view rotation
int offsetX = 0, offsetY = 0, clickX = 0, clickY = 0;
float rotationX = 0, rotationY = 0, targetRotationX = 0, targetRotationY = 0, clickRotationX, clickRotationY; 


void setup() {
  size(800,800,P3D);
  smooth(8);
  fill(255);
  strokeWeight(1/400.0);

  // fill array
  float u, v;
  for (int iv = 0; iv <= vCount; iv++) {
    for (int iu = 0; iu <= uCount; iu++) {
      u = map(iu, 0, uCount, uMin, uMax);
      v = map(iv, 0, vCount, vMin, vMax);

      points[iv][iu] = new PVector();
      points[iv][iu].x = v;
      points[iv][iu].y = sin(u)*cos(v);
      points[iv][iu].z = cos(u)*cos(v);
    }
  }

}


void draw() {
  background(255);

  setView();

  scale(200);

  // draw mesh
  for (int iv = 0; iv < vCount; iv++) {
    beginShape(QUAD_STRIP);
    for (int iu = 0; iu <= uCount; iu++) {
      vertex(points[iv][iu].x, points[iv][iu].y, points[iv][iu].z);
      vertex(points[iv+1][iu].x, points[iv+1][iu].y, points[iv+1][iu].z);
    }
    endShape();
  }